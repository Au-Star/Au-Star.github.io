<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>发现一个Bug如何定位是前端还是后台问题</title>
      <link href="2020/12/14/fa-xian-yi-ge-bug-ru-he-ding-wei-shi-qian-duan-huan-shi-hou-tai-wen-ti/"/>
      <url>2020/12/14/fa-xian-yi-ge-bug-ru-he-ding-wei-shi-qian-duan-huan-shi-hou-tai-wen-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>后端的Bug，如何准确的定位问题在哪里，如何精准的描述Bug？</strong></p><p>（1）查看报错日志</p><p> 查看报错日志，通过日志分析，需要有一定的经验，并且有一定的代码基础，才能更好地定位问题。</p><p>（2）查看数据库的数据</p><p> 了解所测功能的数据表结构，测试过程中，查看数据库的数据，确认数据的正确性。</p><p>（3）查看缓存（如Memcache、apc、redis等缓存）是否正确</p><p><strong>现在来分析bug可能是前台还是后台：</strong></p><p>case1：文本框输入不合法的内容，点击提交按钮， 如果不合法的内容提交成功， 那应该是前后台没有做校验， 前后台都有这个bug</p><p>case2：文本框输入合法的内容，点击提交按钮， 查看数据库中的数据和输入的内容不一致， 这个时候需要看前台传的数据是否正确，使用fiddler抓包， 查看请求头里面的数据是否和输入一致，如果一致就是后台的问题， 如果不一致，就是前台的bug</p><p>case3：界面展示不友好， 重复提交 这些都是前台的bug</p><p><strong>前台定位方法：</strong></p><p>前台bug定位：按F12在console中查看报错信息，对于出错的js可以在Sources下查看对应报错的资源文件，写入禅道提交给开发即可</p><p>前台bug注意以下三个方面：</p><p>（1）网站前台的权限控制：没有权限的用户是不能直接输入url的方式来进行访问的，必须进行登录。以后涉及到权限的测试，一定不能漏掉url的方式也需要验证一下。而在单个页面进行W3C测试时则需要去掉该权限控制。</p><p>（2）网站前台的title，对于这个也很容易忽视。进入到不同的功能页面，title显示应该是有，并且要和你进入的页面一致。title就是在浏览器最左上角看到的那些文字 </p><p>（3）http和https的注意点：https是一种安全链接，它是需要证书的，而http就是普通链接，所以在你的系统中客户会要求某些关键的地方希望加上这种安全连接，那么此时你需要注意的是，对于不需要的安全链接的地方千万也要去重点测试，有些开发会很容易忽略这一点。</p><p>你要打开HTTPS开头的网站，前提是该网站安装了SSL证书，只有安装了SSL证书的网站，并且开启了443端口，你才可以通过HTTPS加密协议无访问。如果没有则不能访问。比如在某个网站http协议后面加个s去访问，看能否访问成功，能成功，会显示绿色安全小锁，否则就不能访问。给你举几个安装了ssl证书，可要https访问的网站，1号店，天猫，淘宝，支付宝，百度，沃通CA，工信部网站等等</p><p><strong>前端bug主要分为3个类别：**</strong>HTML,CSS,Javascript三类问题**</p><p>给个最大的区别方式方法：</p><p>出现样式的问题基本都是CSS的bug</p><p>出现文本的问题基本都是html的bug</p><p>出现交互类的问题基本都是Javascript的bug</p><p>现在以淘宝的前端人员工作为例进行相关bug定位的剖析</p><p><strong>判断前后台问题的区分方法：</strong></p><p>F12, 打开错误控制台console</p><p>区分前后台交互：查看网络请求</p><p>a) Html中如果有链接，有相应的情况下，基本可以定位到是属于前端的问题</p><p>b) 如果为空，或者有出现error错误信息，我们就可以定位到属于后台开发的问题</p><p>TMS对应的VM模板，出现的一些截断控制，转换功能都属于前端的问题</p><p>一、HTML</p><p>最常见的HTML的问题—就是标签的问题了，最常见的排查和解决办法就是查看页面源代码，然后通过检查标签的工具，现在暂时提供idea.exe进行检查，有其他更好的工具再进行推荐。</p><p>常见问题类别：</p><p>标签闭合—表象，页面中出现大范围的混乱，就是少了标签的情况，导致标签未闭合</p><p>标签浮出—例如鼠标移动到文本位置，浮出全名的这种浮出形式都属于标签浮出的问题</p><p>标签在不同的浏览器的一种解析方式的不同导致的前端bug例如如下结构 </p><p>该部分可以看做为一个大的框即是标签<a> 内嵌标题的标签</a></p><p><a>，里面再有这些个内容<ing>,那么在不同的浏览器中，可能ie和FF的解析会产生不同，假设IE解析为</ing></a><a></a></p><p><a><ing></ing></a></p><p></p>的一种形式，但在FF下可能解析为<p></p><p><a><ing></ing></a></p><p></p><p>的两行的形式从而导致前端在复古鞋/板鞋这块ing里面的格式产生混乱</p><p>结构可看为：</p><p>页面定点的问题：最明显的前端功能，在于点击某个链接将页面位置定位到对应的位置</p><p>a) 我们可以通过右键，查看元素的工具进行定位到毛点所定位到的位置，如果出现问题这种问题很直观，并且能通过这种方法直接定位到问题页面的跳转，也属于html的问题，大家在出现点击未跳转或者跳转方式不正确的问题，直接可以定位到跳转属性的问题，找到对应的跳转对应的块提供给开发人员即可</p><p>二、CSS，产生样式问题。例如：排版，布局，颜色，背景等</p><p>css的bug主要分为：兼容型bug 、业务性bug 和 内容型bug</p><p>兼容型bug</p><p>a) 表现：仅在少数几个浏览器上出现</p><p>b) 原因：浏览器的解析不一致</p><p>c) 解决：根据实际情况进行前端代码的通用性 </p><p>d) 类别：</p><p>脚本兼容型问题：在出现对应交互的问题就基本可以定位到脚本兼容型bug，例如DIV的显示和层结构。实际可以参考聚划算的几个商品鼠标移动到小图的时候，对应大图展示的功能。</p><p>页面样式兼容型问题：直接表象在样式上，都是基于框架的页面展示错误，很容易定位业务性bug</p><p>a) 表现：在所有浏览器下都有该问题</p><p>b) 原因：对业务不熟悉</p><p>c) 解决：根据需求进行修改达到业务要求</p><p>该类型的定位，主要在和实现的要求不一致，最直接表现在页面的友好型，用户的可用性的bug，可以定位为该类型内容型bug</p><p>a) 表现： 前端自测正确，但在填入内容后，出现的错误，内容消失等</p><p>b) 原因： 扩展性未考虑周全</p><p>c) 解决： 进行overflow test</p><p>输入内容的长度限制等功能可定位为内容型bug</p><p>三、Javascript</p><p>最直接的判断方法，刷新页面，出现滞后显示的一些模块基本都为脚本的输出块。该部分的一些问题可以参照兼容型bug中类别的脚本兼容型bug。 </p><p>有产生交互类的问题，大多数都可以定位到是属于javascript产生的问题，该部分大多不会报错有错误提示类的。页面左下方有出现javascript的错误提示；有弹出错误信息提示的bug；浏览器返回的一些错误弹出框都属于javascript的bug</p>]]></content>
      
      
      <categories>
          
          <category> 定位BUG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定位BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学测试</title>
      <link href="2020/12/14/chu-xue-ce-shi/"/>
      <url>2020/12/14/chu-xue-ce-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-测试定义"><a href="#1-测试定义" class="headerlink" title="1.测试定义"></a>1.测试定义</h2><p>​    标准定义：<strong>在规定的条件下对程序进行操作，以发现错误，对软件质量进行评估</strong></p><p>​    简单的说就是： <strong>在软件中找存在的BUG</strong></p><h2 id="2-测试的分类"><a href="#2-测试的分类" class="headerlink" title="2.测试的分类"></a>2.测试的分类</h2><h3 id="1-按照开发阶段划分："><a href="#1-按照开发阶段划分：" class="headerlink" title="1.按照开发阶段划分："></a>1.按照开发阶段划分：</h3><p>​        单元测试    集成测试    系统测试    验收测试</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">### </span>单元测试，又称模块测试。对软件的组成单位进行测试，其目的是检验软件基本组成单位的正确性。测试的对象的是软件你测试的最小单位：模块<span class="token comment" spellcheck="true">###</span>集成测试也称联合测试（联调）、组装测试：将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。集成主要目的是检查软件单位之间的接口是否正确。<span class="token comment" spellcheck="true">###</span>系统测试：将软件系统看成是一个系统的测试。包括对功能、性能以及软件所运行的软硬件环境进行测试。时间大部分在系统测试执行阶段，包括回归测试和冒烟测试。    <span class="token number">1</span><span class="token punctuation">.</span>回归测试（Regression Testing）：指修改了旧的代码之后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。（自动回归测试将大幅度降低系统测试、维护升级等阶段的成本）。    <span class="token number">2</span><span class="token punctuation">.</span>冒烟测试（smoke testing）：该术语来自硬件，指对一个硬件或一组硬件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试，也可以理解为该种测试耗时短，仅用一袋烟的功夫就足够了<span class="token comment" spellcheck="true">###</span>验收测试（交付测试）：是部署软件之前的最后一个测试操作。它是技术测试的最后一个阶段，也称为交付测试。验收测试的目的是确保软件准备就绪，按照项目合同、任务书、双方约定的验收依据文档，向软件购买都展示该软件系统满足原始需求。</code></pre><h3 id="2-按照是否查看代码划分："><a href="#2-按照是否查看代码划分：" class="headerlink" title="2.按照是否查看代码划分："></a>2.按照是否查看代码划分：</h3><p>​        黑盒测试    白盒测试    灰盒测试</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">###</span>黑盒测试也是功能测试，测试中把被测的软件当成一个黑盒子，不关心盒子的内部结构是什么，只关心软件的输入数据和输出数据。<span class="token comment" spellcheck="true">###</span>白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是指打开盒子，去研究里面的源代码和程序结果。<span class="token comment" spellcheck="true">###</span>灰盒测试是介于白盒测试和黑盒测试之间的一种，灰盒测试多用于集成测试阶段，不仅关注输入、输出的正确性，同时也关注程序内部的情况。</code></pre><h3 id="3-按照测试是否执行划分："><a href="#3-按照测试是否执行划分：" class="headerlink" title="3.按照测试是否执行划分："></a>3.按照测试是否执行划分：</h3><p>​        静态测试    动态测试</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">###</span>静态方法是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性，对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错<span class="token comment" spellcheck="true">###</span>动态测试是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性、健壮性、等性能</code></pre><h3 id="4-按照测试对象划分："><a href="#4-按照测试对象划分：" class="headerlink" title="4. 按照测试对象划分："></a>4. 按照测试对象划分：</h3><p>​        性能测试    安全测试    兼容性测试    文档测试    界面测试    </p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">###</span><span class="token number">1</span><span class="token punctuation">.</span>性能测试检查系统是否满足需求规格说明书中规定的性能。通常表现在以下几个方面：    对资源利用（如内存、处理机周期等）进行的精确度量        对执行间隔    日志事件（如中断，报错）    响应时间    吞吐量（TPS）    辅助存储区（例如缓冲区、工作区的大小等）    处理精度等进行的监测<span class="token comment" spellcheck="true">###</span><span class="token number">2</span><span class="token punctuation">.</span>安全测试安全测试是一个相对独立的领域，需要更多的专业知识。如：WEB的安全测试、需要熟悉各种网络协议、防火墙、CDN、熟悉各种操作系统的漏洞、熟悉路由器等。<span class="token comment" spellcheck="true">###</span><span class="token number">3</span><span class="token punctuation">.</span>兼容性测试兼容性测试主要是指，软件之间能否很好的运作，会不会有影响、软件和硬件之间能否发挥很好的效率工作，会不会影响导致系统的崩溃。    平台测试    浏览器测试    软件本身能否向前或向后兼容    测试软件能否与其它相关软件兼容    数据兼容性测试最常见的兼容性测试就是浏览器的兼容性测试，不同浏览器在css，js解析上的不同会导致页面显示不同。常见的IE8的兼容性。<span class="token comment" spellcheck="true">###</span><span class="token number">5</span><span class="token punctuation">.</span>易用性测试（用户体验测试）易用性（Useability）是交互的适应性、功能性和有效性的集中体现。又叫用户体验测试。<span class="token comment" spellcheck="true">###</span><span class="token number">6</span><span class="token punctuation">.</span>业务测试业务测试是指：测试人员将系统的整个模块串接起来运行、模拟真实用户实际的工作流程。满足用户需求定义的功能来进行测试的过程。<span class="token comment" spellcheck="true">###</span><span class="token number">7</span><span class="token punctuation">.</span>界面测试界面测试（简称UI测试<span class="token punctuation">)</span>，测试用户界面的功能模块的布局是否合理、整体风格是否一致、各个控件的放置位置是否符合客户使用习惯，此外还要测试界面操作便捷性、导航简单易懂性，页面元素的可用性，界面中文字是否正确，命名是否统一，页面是否美观，文字、图片组合是否完美等。</code></pre><h2 id="3-测试的方法"><a href="#3-测试的方法" class="headerlink" title="3.测试的方法"></a>3.测试的方法</h2><p>​    等价类划分： 有效等价类和无效等价类    边界值分析法    因果图法    场景法    正交表</p><p>​    。。。未完待续</p><h2 id="4-测试的生命周期"><a href="#4-测试的生命周期" class="headerlink" title="4.测试的生命周期"></a>4.测试的生命周期</h2><p>​    需求分析    测试计划    环境设置    测试用例    缺陷记录    测试周期</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">###</span><span class="token number">1</span><span class="token punctuation">.</span>需求分析在此阶段，测试人员分析需求文档，已检查客户所述的要求。在检查要求后，测试人员制定测试计划以检查软件是否满足需求。    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>进入条件 <span class="token operator">-</span> 对于测试计划需求规范的规划，应该提供应用程序体系结构文档和明确定义的验收标准。    <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>活动行为 <span class="token operator">-</span> 准备所有要求和查询的列表，并从技术经理<span class="token operator">/</span>主管，系统架构，业务分析师和客户处获得解决。列出要执行的所有类型的测试<span class="token punctuation">(</span>性能，功能和安全性<span class="token punctuation">)</span>。列出测试环境详细信息，其中应包含执行测试用例的所有必要工具。    <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>交付成果 <span class="token operator">-</span> 列出可测试要求和测试环境详细信息的所有必要测试。<span class="token comment" spellcheck="true">###</span><span class="token number">2</span><span class="token punctuation">.</span>创建测试计划的创建是STLC<span class="token punctuation">(</span>软件测试生命周期<span class="token punctuation">)</span>的关键阶段，它定义了所有测试策略。测试人员确定整个项目的估计工作量和成本。此阶段在成功完成需求分析阶段后进行。此阶段提供的测试策略和工作量估算文档。成功完成测试计划创建后，可以开始测试用例执行。    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>进入条件 <span class="token operator">-</span> 需求文档活动行为 <span class="token operator">-</span> 定义目标以及软件的范围。列出测试中涉及的方法。测试过程概述。    <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>测试环境的解决。准备测试计划和控制程序。角色和责任的确定。列出测试可交付成果，定义风险<span class="token punctuation">(</span>如果有<span class="token punctuation">)</span>。    <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>交付成果 <span class="token operator">-</span> 测试策略文档。测试估算文件是此阶段的交付成果。<span class="token comment" spellcheck="true">###</span><span class="token number">3</span><span class="token punctuation">.</span> 环境设置测试环境的设置是一项独立的活动，可以与测试用例开发一起启动。这是手动测试程序的重要部分，因为没有环境测试无法进行。环境设置需要一组必要的软件和硬件来创建测试环境。测试团队不参与设置测试环境，而是创建测试环境的高级开发人员完成。    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>进入条件 <span class="token operator">-</span> 测试策略和测试计划文档。测试用例文档。测试数据。    <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>活动行为 <span class="token operator">-</span> 通过分析需求规范来准备软件和硬件列表。在设置测试环境之后，执行测试用例以检查测试环境的准备情况。    <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>交付成果 <span class="token operator">-</span> 执行报告。缺陷报告。<span class="token comment" spellcheck="true">###</span><span class="token number">4</span><span class="token punctuation">.</span> 测试用例执行测试用例在成功完成测试计划后执行。在此阶段，测试团队启动案例开发和执行活动。测试团队记下详细的测试用例，并在需要时准备测试数据。准备好的测试用例由团队的同行成员或质量保证负责人进行审核。 RTM<span class="token punctuation">(</span>需求可追溯性矩阵<span class="token punctuation">)</span>也在此阶段准备。需求可跟踪性矩阵是行业级格式，用于跟踪需求。每个测试用例都与需求规范一起映射。可以通过RTM完成向后和向前可追溯性。    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>进入条件 <span class="token operator">-</span> 需求文档。    <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>活动行为 <span class="token operator">-</span> 创建测试用例。执行测试用例。根据要求绘制测试用例。    <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>交付成果 <span class="token operator">-</span> 测试执行结果。具有缺陷详细说明的功能列表。<span class="token comment" spellcheck="true">###</span><span class="token number">5</span><span class="token punctuation">.</span> 缺陷记录测试人员和开发人员根据测试覆盖范围，质量，时间消耗，成本和关键业务目标评估软件的完成标准。此阶段确定了软件的特性和缺点。深入分析测试用例和错误报告，以检测缺陷的类型及其严重性。 缺陷记录分析主要用于根据严重程度和类型找出缺陷分布。如果检测到任何缺陷，则将软件返回给开发团队以修复缺陷，然后在测试的所有方面对软件进行重新测试。 一旦测试周期完全完成，然后测试关闭报告，并准备测试指标。    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>进入条件 <span class="token operator">-</span> 测试用例执行报告。缺陷报告    <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>活动行为 <span class="token operator">-</span> 它根据测试覆盖率，质量，时间消耗，成本和关键业务目标评估软件的完成标准。缺陷记录分析通过对类型和严重性进行分类来找出缺陷分布。    <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>交付成果 <span class="token operator">-</span> 关闭报告，测试指标<span class="token comment" spellcheck="true">###</span><span class="token number">6</span><span class="token punctuation">.</span> 测试周期关闭测试周期结束报告包括与软件设计，开发，测试结果和缺陷报告相关的所有文档。如果存在具有相同规范的软件，此阶段将评估开发策略，测试过程，可能的缺陷，以便将来使用这些实践。    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>进入条件 <span class="token operator">-</span> 所有与软件相关的文档和报告。    <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>活动行为 <span class="token operator">-</span> 如果存在具有相同规范的软件，则评估开发策略，测试过程，将来可能存在的缺陷以使用这些实践。    <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>交付成果 <span class="token operator">-</span> 测试结束报告。</code></pre><h2 id="5-测试用例"><a href="#5-测试用例" class="headerlink" title="5.测试用例"></a>5.测试用例</h2><ol><li><p><strong>测试用例的定义：</strong> </p><p>测试用例是执行测试的依据，把测试系统的操作步骤用文档的形式描述出来</p></li><li><p><strong>测试用例包含？</strong></p><p>用例编号  用例描述  【用例所属模块】  执行条件  预期结果  测试输入   实际结果  【测试人】  【测试版本】 【测试日期】 【备注】</p></li><li><p><strong>测试用例文档的方式</strong></p><p>Excel  word  方式     bug管理工具里可以直接写</p></li><li><p><strong>测试用例开始写的时间</strong></p><p>拿到对应的模块进行编写。</p></li><li><p><strong>测试用例的注意：</strong></p><p>根据需求文档或者是原型图年写的用例的覆盖度[80%-90%].</p><p>书写用例有正反   反向用例【异常用例】   8：1</p><p>代表性：</p><p>针对性：</p><p>可判定性：测试执行结果的正确性是可判定的，每一个测试用例都应有相应的期望结果</p></li></ol><h2 id="6-BUG的定义、分类、生命周期"><a href="#6-BUG的定义、分类、生命周期" class="headerlink" title="6.BUG的定义、分类、生命周期"></a>6.BUG的定义、分类、生命周期</h2><h3 id="1-BUG定义"><a href="#1-BUG定义" class="headerlink" title="1.BUG定义"></a>1.BUG定义</h3><pre class=" language-python"><code class="language-python">软件的bug狭义的是指软件程序的漏洞或缺陷，广义概念除此之外还包括测试工程师或用户发现和提出的软件可改进细节，或与需求文档存在差异的功能实现等。我们的职责就是发现这些bug，提交给开发，让开发去修改</code></pre><h3 id="2-BUG类型"><a href="#2-BUG类型" class="headerlink" title="2.BUG类型"></a>2.BUG类型</h3><pre class=" language-python"><code class="language-python">要确定一个bug类型，需要对项目（或产品）有比较深的理解，这个划分对开发定位问题影响较小，但对于问题类型的统计就比较重要了。常见的bug类型划分：代码错误，界面优化，设计缺陷，配置相关，安装部署，安全相关，性能问题，标准规范，测试脚本，其他。其他划分：功能类，界面类    性能类    易用性类   兼容类    其他缺陷的等级<span class="token punctuation">:</span>bug的等级一般分为四级，也有分五级的，如果是等级越高，那么对应的优先级也会高一些，然后有些公司还会根据你提的bug数量和bug等级，作为绩效考核的一部分。<span class="token number">1</span>）致命性错误    <span class="token number">1</span><span class="token punctuation">.</span>常规操作引起的系统崩溃，死机，死循环    <span class="token number">2</span><span class="token punctuation">.</span>造成数据泄露的安全性问题，比如恶意攻击造成的账户私密信息泄露    <span class="token number">3</span><span class="token punctuation">.</span>涉及金钱    <span class="token number">4</span><span class="token punctuation">.</span>用户数据受到破坏，或者危及人身安全<span class="token number">2</span>）严重错误    <span class="token number">1</span><span class="token punctuation">.</span>重要功能不能实现    <span class="token number">2</span><span class="token punctuation">.</span>错误的波及面广，影响到其他重要功能实现    <span class="token number">3</span><span class="token punctuation">.</span>非常规操作导致的程序崩溃，死机，死循环    <span class="token number">4</span><span class="token punctuation">.</span>数据不能保存，系统的次要功能完全丧失，系统所提供的功能或服务受到明显影响<span class="token number">3</span>）一般错误    不影响产品的运行，不能成为故障起因，但对产品外观和下道工序影响较大的缺陷    <span class="token number">1</span><span class="token punctuation">.</span>次要功能能不能正常实现    <span class="token number">2</span><span class="token punctuation">.</span>操作界面错误（包括数据窗口内列名定义，含义不一致）    <span class="token number">3</span><span class="token punctuation">.</span>查询错误，数据错误显示    <span class="token number">4</span><span class="token punctuation">.</span>简单的输入限制未放在前台进行控制    <span class="token number">5</span><span class="token punctuation">.</span>删除操作未给出提示<span class="token number">4</span>）细微错误    程序在一些显示上不美观，不符合用户习惯，或者是一些文字的错误    <span class="token number">1</span><span class="token punctuation">.</span>界面不规范    <span class="token number">2</span><span class="token punctuation">.</span>辅助说明描述不清楚    <span class="token number">3</span><span class="token punctuation">.</span>提示窗口文字未采用行业术语    <span class="token number">4</span><span class="token punctuation">.</span>界面存在文字性错误优先级分为<span class="token number">4</span>级，一般问题越严重，其处理的优先级越高</code></pre><h3 id="3-BUG生命周期"><a href="#3-BUG生命周期" class="headerlink" title="3.BUG生命周期"></a>3.BUG生命周期</h3><pre class=" language-python"><code class="language-python">就是一个bug被发现到这个bug被关闭的过程<span class="token number">1</span><span class="token punctuation">.</span>发现bug<span class="token operator">-</span><span class="token operator">-</span>提交bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>指派bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>研发确认bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>（否）设计如此  重复bug<span class="token punctuation">,</span>无法重现                                                      <span class="token number">2</span><span class="token punctuation">.</span>发现bug<span class="token operator">-</span><span class="token operator">-</span>提交bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>指派bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>研发确认bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">(</span>是）研发是否解决<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>（否）不予解决，延期<span class="token number">3</span><span class="token punctuation">.</span>发现bug<span class="token operator">-</span><span class="token operator">-</span>提交bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>指派bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>研发确认bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">(</span>是）研发是否解决<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>（是）回归验证bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>是否通过验证<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>（是） 关闭bug<span class="token number">4</span><span class="token punctuation">.</span>发现bug<span class="token operator">-</span><span class="token operator">-</span>提交bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>指派bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>研发确认bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">(</span>是）研发是否解决<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>（是）回归验证bug<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>是否通过验证<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>（否） 激活<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>指派bug</code></pre><h2 id="7-面试题："><a href="#7-面试题：" class="headerlink" title="7.面试题："></a>7.面试题：</h2><p><strong>1.有没有你印象深刻的bug?</strong></p><p>有很多印象深刻的bug,比如说后台播放 av source时rev on开启back camera后，关闭，重复开启-关闭几次后机器出现重启。</p><p><strong>2.bug的生命周期</strong></p><p>新建bug指派给开发–开发已解决—-评价验证bug,修复后—关闭bug </p><p>当你打开了一个bug,但开放不认为是bug,如何处理？</p><p>首先查找需求说明书和式样书，寻找确切的依据，如果是用户体验票，侧从用户的角度来说明为什么是bug,如果开发依然认为不是bug的话，交由产品经理来判定 </p><p><strong>3.对于复现率不高的bug如何处理？你再发现bug并确认bug的过程中</strong></p><p>复现率不高的bug要立马录像，拍照片，截取log,保留现场，直接叫开发来调查问题。</p><p>如果现场已经被破坏，只能在以后每天的测试中带着再现，把这个问题在测试人员中展开一下，别的测试人员也可以帮忙验证。</p>]]></content>
      
      
      <categories>
          
          <category> 初学测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初学测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows ADB配置java adk  Android adk</title>
      <link href="2020/12/14/windows-adb-pei-zhi-java-adk-android-adk/"/>
      <url>2020/12/14/windows-adb-pei-zhi-java-adk-android-adk/</url>
      
        <content type="html"><![CDATA[<h2 id="1-java配置"><a href="#1-java配置" class="headerlink" title="1.java配置"></a>1.java配置</h2><p>​    1.安装jdk的按装包（傻瓜式安装不需要更改路径）</p><p>​    2.我的电脑右击属性–高级系统设置–环境变量<br>         用户变量 新建<br>             JAVA_HOME<br>             C:\Program Files\Java\jdk1.8.0_144（自己的实际路径名）<br>         系统用户变量 新建<br>​            C:\Program Files\Java\jdk1.8.0_144\bin（自己的实际路径名）</p><p>​    3.点击确定</p><p>​    4.验证：<br>  　　运行输入cmd 在黑窗口中输入  java  javac</p><h2 id="2-Android-sdk"><a href="#2-Android-sdk" class="headerlink" title="2.Android -sdk"></a>2.Android -sdk</h2><p>​    1.解压压缩包<br> 　　2.我的电脑右击属性–高级系统设置–环境变量<br>  　　用户变量 新建<br>  　　ANDROID_HOME<br>  　　D:\android-sdk</p><p>　　（D:\android-sdk\platform-tools （自己的实际路径名）D:\android-sdk\tools （自己的实际路径名））部分机型自带 确认打不开后可自行配置<br>  　　系统用户变量中<br> 　　 D:\android-sdk\platform-tools （自己的实际路径名）<br>  　　D:\android-sdk\tools （自己的实际路径名）</p><p>  　　3.点击确定<br>  　　4.验证：<br>   　　 运行输入cmd 在黑窗口中输入  ADB</p>]]></content>
      
      
      <categories>
          
          <category> ADB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web测试方法总结</title>
      <link href="2020/12/14/web-duan-ru-he-pei-zhi/"/>
      <url>2020/12/14/web-duan-ru-he-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>web测试方法总结</p><h2 id="一、输入框"><a href="#一、输入框" class="headerlink" title="一、输入框"></a>一、输入框</h2><h3 id="1、字符型输入框："><a href="#1、字符型输入框：" class="headerlink" title="1、字符型输入框："></a>1、字符型输入框：</h3><p>（1）字符型输入框：英文全角、英文半角、数字、空或者空格、特殊字符“~！@#￥%……&amp;*？[]{}”特别要注意单引号和&amp;符号。禁止直接输入特殊字符时，使用“粘贴、拷贝”功能尝试输入。</p><p>（2）长度检查：最小长度、最大长度、最小长度-1、最大长度+1、输入超工字符比如把整个<strong>文章</strong>拷贝过去。</p><p>（3）空格检查：输入的字符间有空格、字符前有空格、字符后有空格、字符前后有空格</p><p>（4）多行文本框输入：允许回车换行、保存后再显示能够保存输入的格式、仅输入回车换行，检查能否正确保存（若能，检查保存结果，若不能，查看是否有正常提示）、</p><p>（5）安全性检查：输入特殊字符串（null,NULL, ,javascript,<script>,</script>,<title>,&lt;html&gt;,&lt;td&gt;）、输入脚本函数(&lt;script&gt;alert("abc")&lt;/script&gt;)、doucment.write(“abc”)、&lt;b&gt;hello&lt;/b&gt;）&lt;/td&gt;&lt;/html&gt;</title></p><h3 id="2、数值型输入框："><a href="#2、数值型输入框：" class="headerlink" title="2、数值型输入框："></a>2、数值型输入框：</h3><p>（1）边界值：最大值、最小值、最大值+1、最小值-1 </p><p>（2）位数：最小位数、最大位数、最小位数-1最大位数+1、输入超长值、输入整数 </p><p>（3）异常值、特殊字符：输入空白（NULL）、空格或”~!@#$%^&amp;*()_+{}|[]:“&lt;&gt;?;’,./?;:’-=等可能导致系统错误的字符、禁止直接输入特殊字符时，尝试使用粘贴拷贝查看是否能正常提交、word中的特殊功能，通过剪贴板拷贝到输入框，分页符，分节符类似公式的上下标等、数值的特殊符号如∑，㏒，㏑，∏，+，-等、</p><p>输入负整数、负小数、分数、输入字母或汉字、小数（小数前0点舍去的情况，多个小数点的情况）、首位为0的数字如01、02、科学计数法是否支持1.0E2、全角数字与半角数字、数字与字母混合、16进制，8进制数值、货币型输入（允许小数点后面几位）、</p><p>（4）安全性检查：不能直接输入就copy</p><h3 id="3、日期型输入框："><a href="#3、日期型输入框：" class="headerlink" title="3、日期型输入框："></a>3、日期型输入框：</h3><p>（1）合法性检查：(输入0日、1日、32日)、月输入[1、3、5、7、8、10、12]、日输入[31]、月输入[4、6、9、11]、日输入[30][31]、输入非闰年，月输入[2]，日期输入[28、29]、输入闰年，月输入[2]、日期输入[29、30]、月输入[0、1、12、13]</p><p> (2)异常值、特殊字符：输入空白或NULL、输入~！@#￥%……&amp;*（）{}[]等可能导致系统错误的字符</p><p>（3）安全性检查：不能直接输入，就copy，是否数据检验出错？</p><p>4、信息重复:在一些需要命名,且名字应该唯一的信息输入重复的名字或ID,看系统有没有处理,会否报错,重名包括是否区分大小写,以及在输入内容的前后输入空格,系统是否作出正确处理.</p><h2 id="二、搜索功能"><a href="#二、搜索功能" class="headerlink" title="二、搜索功能"></a>二、搜索功能</h2><p>若查询条件为输入框，则参考输入框对应类型的测试方法</p><h3 id="1、功能实现："><a href="#1、功能实现：" class="headerlink" title="1、功能实现："></a>1、功能实现：</h3><p>（1）如果支持模糊查询，搜索名称中任意一个字符是否能搜索到</p><p>（2）比较长的名称是否能查到</p><p>（3）输入系统中不存在的与之匹配的条件</p><p>（4）用户进行查询操作时，一般情况是不进行查询条件的清空，除非需求特殊说明。</p><h3 id="2、组合测试："><a href="#2、组合测试：" class="headerlink" title="2、组合测试："></a>2、组合测试：</h3><p>（1）不同查询条件之间来回选择，是否出现页面错误（单选框和多选框最容易出错）</p><p>（2）测试多个查询条件时，要注意查询条件的组合测试，可能不同组合的测试会报错。</p><h2 id="三、添加、修改功能"><a href="#三、添加、修改功能" class="headerlink" title="三、添加、修改功能"></a>三、添加、修改功能</h2><h3 id="1、特殊键："><a href="#1、特殊键：" class="headerlink" title="1、特殊键："></a>1、特殊键：</h3><p>（1）是否支持Tab键 （2）是否支持回车键</p><h3 id="2、提示信息："><a href="#2、提示信息：" class="headerlink" title="2、提示信息："></a>2、提示信息：</h3><p>（1）不符合要求的地方是否有错误提示</p><h3 id="3、唯一性："><a href="#3、唯一性：" class="headerlink" title="3、唯一性："></a>3、唯一性：</h3><p>（1）字段唯一的，是否可以重复添加，添加后是否能修改为已存在的字段（字段包括区分大小写以及在输入的内容前后输入空格，保存后，数据是否真的插入到<strong>数据库</strong>中，注意保存后数据的正确性）</p><h3 id="4、数据-正确性："><a href="#4、数据-正确性：" class="headerlink" title="4、数据 正确性："></a>4、数据 正确性：</h3><p>（1）对编辑页的每个编辑项进行修改，点击保存，是否可以保存成功，检查想关联的数据是否得到更新。</p><p>（2）进行必填项检查（即是否给出提示以及提示后是否依然把数据存到数据库中；是否提示后出现页码错乱等）</p><p>（3）是否能够连续添加（针对特殊情况）</p><p>（4）在编辑的时候，注意编辑项的长度限制，有时在添加的时候有，在编辑的时候却没有（注意要添加和修改规则是否一致）</p><p>（5）对于有图片上传功能的编辑框，若不上传图片，查看编辑页面时是否显示有默认的图片，若上传图片，查看是否显示为上传图片</p><p>（6）修改后增加数据后，特别要注意查询页面的数据是否及时更新，特别是在首页时要注意数据的更新。</p><p>（7）提交数据时，连续多次点击，查看系统会不会连续增加几条相同的数据或报错。</p><p>（8）若结果列表中没有记录或者没选择某条记录，点击修改按钮，系统会抛异常。</p><h2 id="四、删除功能"><a href="#四、删除功能" class="headerlink" title="四、删除功能"></a>四、删除功能</h2><h3 id="1、特殊键：-1"><a href="#1、特殊键：-1" class="headerlink" title="1、特殊键："></a>1、特殊键：</h3><p>（1）是否支持Tab键 （2）是否支持回车键</p><h3 id="2、提示信息：-1"><a href="#2、提示信息：-1" class="headerlink" title="2、提示信息："></a>2、提示信息：</h3><p>（1）不选择任何信息，直接点击删除按钮，是否有提示（2）删除某条信息时，应该有确认提示</p><h3 id="3、数据-实现："><a href="#3、数据-实现：" class="headerlink" title="3、数据 实现："></a>3、数据 实现：</h3><p>（1）是否能连续删除多个产品（2）当只有一条数据时，是否可以删除成功 （3）删除一条数据后，是否可以添加相同的数据（4）如系统支持批量删除，注意删除的信息是否正确 （5）如有全选，注意是否把所有的数据删除（6）删除数据时，要注意相应查询页面的数据是否及时更新 （7）如删除的数据与<strong>其他</strong>业务数据关联，要注意其关联性（如删除部门信息时，部门下游员工，则应该给出提示）（8）如果结果列表中没有记录或没有选择任何一条记录，点击删除按钮系统会报错。</p><p>如：某一功能模块具有最基本的增删改查功能，则需要进行以下测试</p><p>单项<strong>功能测试</strong>（增加、修改、查询、删除）</p><p>增加——&gt;增加——&gt;增加 （连续增加测试）</p><p>增加——&gt;删除</p><p>增加——&gt;删除——&gt;增加 （新增加的内容与删除内容一致）</p><p>增加——&gt;修改——&gt;删除</p><p>修改——&gt;修改——&gt;修改 （连续修改测试）</p><p>修改——&gt;增加（新增加的内容与修改前内容一致）</p><p>修改——&gt;删除</p><p>修改——&gt;删除——&gt;增加 （新增加的内容与删除内容一致）</p><p>删除——&gt;删除——&gt;删除 （连续删除测试）</p><h2 id="五、注册、登陆模块"><a href="#五、注册、登陆模块" class="headerlink" title="五、注册、登陆模块"></a>五、注册、登陆模块</h2><h3 id="1、注册功能："><a href="#1、注册功能：" class="headerlink" title="1、注册功能："></a>1、注册功能：</h3><p>（1）注册时，设置密码为特殊版本号，检查登录时是否会报错</p><p>（2）注册成功后，页面应该以登陆状态跳转到首页或指定页面</p><p>（3）在注册信息中删除已输入的信息，检查是否可以注册成功。</p><h3 id="2、登陆-功能："><a href="#2、登陆-功能：" class="headerlink" title="2、登陆 功能："></a>2、登陆 功能：</h3><p>（1）输入正确的用户名和正确的密码</p><p>（2）输入正确的用户名和错误的密码</p><p>（3）输入错误的用户名和正确的密码</p><p>（4）输入错误的用户名和错误的密码</p><p>（5）不输入用户名和密码（均为空格）</p><p>（6）只输入用户名，密码为空</p><p>（7）用户名为空，只输入密码</p><p>（8）输入正确的用户名和密码，但是不区分大小写</p><p>（9）用户名和密码包括特殊字符</p><p>（10）用户名和密码输入超长值</p><p>（11）已删除的用户名和密码</p><p>（12）登录时，当页面刷新或重新输入数据时，验证码是否更新</p><h2 id="六、上传图片测试"><a href="#六、上传图片测试" class="headerlink" title="六、上传图片测试"></a>六、上传图片测试</h2><h3 id="1、功能-实现："><a href="#1、功能-实现：" class="headerlink" title="1、功能 实现："></a>1、功能 实现：</h3><p>（1）文件类型正确、大小合适</p><p>（2）文件类型正确，大小不合适</p><p>（3）文件类型错误，大小合适</p><p>（4）文件类型和大小都合适，上传一个正在使用中的图片</p><p>（5）文件类型大小都合适，手动输入存在的图片地址来上传</p><p>（6）文件类型和大小都合适，输入不存在的图片地址来上传</p><p>（7）文件类型和大小都合适，输入图片名称来上传</p><p>（8）不选择文件直接点击上传，查看是否给出提示</p><p>（9）连续多次选择不同的文件，查看是否上传最后一次选择的文件</p><h2 id="七、查询结果列表"><a href="#七、查询结果列表" class="headerlink" title="七、查询结果列表"></a>七、查询结果列表</h2><h3 id="1、功能-实现：-1"><a href="#1、功能-实现：-1" class="headerlink" title="1、功能 实现："></a>1、功能 实现：</h3><p>（1）列表、列宽是否合理</p><p>（2）列表数据太宽有没有提供横向滚动</p><p>（3）列表的列名有没有与内容对应</p><p>（4）列表的每列的列名是否描述的清晰</p><p>（5）列表是否把不必要的列都显示出来</p><p>（6）点击某列进行排序，是否会报错（点击查看每一页的排序是否正确）</p><p>（7）双击或单击某列信息，是否会报错</p><h2 id="八、返回键检查"><a href="#八、返回键检查" class="headerlink" title="八、返回键检查"></a>八、返回键检查</h2><p>1、一条已经成功提交的记录，返回后再提交，是否做了处理</p><p>2、检查多次使用返回键的情况，在有返回键的地方，返回到原来的页面多次，查看是否会出错</p><h2 id="九、回车键检查"><a href="#九、回车键检查" class="headerlink" title="九、回车键检查"></a>九、回车键检查</h2><p>1、在输入结果后，直接按回车键，看系统如何处理，是否会报错</p><h2 id="十、刷新键检查"><a href="#十、刷新键检查" class="headerlink" title="十、刷新键检查"></a>十、刷新键检查</h2><p>1、在Web系统中，使用刷新键，看系统如何处理，是否会报错</p><h2 id="十一、直接URL链接检查"><a href="#十一、直接URL链接检查" class="headerlink" title="十一、直接URL链接检查"></a>十一、直接URL链接检查</h2><p>1、在Web系统中，在地址栏直接输入各个功能页面的URL地址，看系统如何处理，是否能够直接链接查看（匿名查看），是否有权限控制，是否直接执行，并返回相应结果页；</p><h2 id="十二、界面和易用性测试"><a href="#十二、界面和易用性测试" class="headerlink" title="十二、界面和易用性测试"></a>十二、界面和易用性测试</h2><p>1、风格、样式、颜色是否协调</p><p>2、界面布局是否整齐、协调（保证全部显示出来的，尽量不要使用滚动条</p><p>3、界面操作、标题描述是否恰当（描述有歧义、注意是否有错别字）</p><p>4、操作是否符合人们的常规习惯（有没有把相似的功能的控件放在一起，方便操作）</p><p>5、提示界面是否符合规范（不应该显示英文的cancel、ok，应该显示中文的确定等）</p><p>6、界面中各个控件是否对齐</p><p>7、日期控件是否可编辑</p><p>8、日期控件的长度是否合理，以修改时可以把时间全部显示出来为准</p><p>9、查询结果列表列宽是否合理、标签描述是否合理</p><p>10、查询结果列表太宽没有横向滚动提示</p><p>11、对于信息比较长的文本，文本框有没有提供自动竖直滚动条</p><p>12、数据录入控件是否方便</p><p>13、有没有支持Tab键，键的顺序要有条理，不乱跳</p><p>14、有没有提供相关的热键</p><p>15、控件的提示语描述是否正确</p><p>16、模块调用是否统一，相同的模块是否调用同一个界面</p><p>17、用滚动条移动页面时，页面的控件是否显示正常</p><p>18、日期的正确格式应该是XXXX-XX-XX或XXXX-XX-XX XX:XX:XX</p><p>19、页面是否有多余按钮或标签</p><p>20、窗口标题或图标是否与菜单栏的统一</p><p>21、窗口的最大化、最小化是否能正确切换</p><p>22、对于正常的功能，用户可以不必阅读用户手册就能使用</p><p>23、执行风险操作时，有确认、删除等提示吗</p><p>24、操作顺序是否合理</p><p>25、正确性检查：检查页面上的form, button, table, header, footer,提示信息，还有<strong>其他</strong>文字拼写，句子的语法等是否正确。</p><p>26、系统应该在用户执行错误的操作之前提出警告，提示信息.</p><p>27、页面分辨率检查，在各种分辨率浏览系统检查系统界面友好性。</p><p>28、合理性检查：做delete, update, add, cancel, back等操作后，查看信息回到的页面是否合理。</p><p>29、检查本地化是否通过：英文版不应该有中文信息，英文翻译准确，专业。</p><h2 id="十三、兼容性测试"><a href="#十三、兼容性测试" class="headerlink" title="十三、兼容性测试"></a>十三、兼容性测试</h2><p>兼容性测试不只是指界面在不同<strong>操作系统</strong>或浏览器下的兼容，有些功能方面的测试，也要考虑到兼容性，</p><p>包括操作系统兼容和应用软件兼容，可能还包括硬件兼容</p><p>比如涉及到ajax、jquery、javascript等技术的，都要考虑到不同浏览器下的兼容性问题。</p><h2 id="十四、链接测试"><a href="#十四、链接测试" class="headerlink" title="十四、链接测试"></a>十四、链接测试</h2><p>主要是保证链接的可用性和正确性，它也是网站测试中比较重要的一个方面。</p><p>可以使用特定的工具如XENU来进行链接测试。</p><h3 id="1导航测试"><a href="#1导航测试" class="headerlink" title="1导航测试"></a>1导航测试</h3><p>导航描述了用户在一个页面内操作的方式，在不同的用户接口控制之间，例如按钮、对话框、列表和窗口等；或在不同的连接页面之间。通过考虑下列问题，可以决定一个Web应用系统是否易于导航：导航是否直观？Web系统的主要部分是否可通过主页存取？Web系统是否需要站点地图、搜索引擎或其他的导航帮助？<br>在一个页面上放太多的信息往往起到与预期相反的效果。Web应用系统的用户趋向于目的驱动，很快地扫描一个Web应用系统，看是否有满足自己需要的信息，如果没有，就会很快地离开。很少有用户愿意花时间去熟悉Web应用系统的结构，因此，Web应用系统导航帮助要尽可能地准确。<br>导航的另一个重要方面是Web应用系统的页面结构、导航、菜单、连接的风格是否一致。确保用户凭直觉就知道Web应用系统里面是否还有内容，内容在什么地方。<br>Web应用系统的层次一旦决定，就要着手测试用户导航功能，让最终用户参与这种测试，效果将更加明显。</p><h3 id="2图形测试"><a href="#2图形测试" class="headerlink" title="2图形测试"></a>2图形测试</h3><p>在Web应用系统中，适当的图片和动画既能起到广告宣传的作用，又能起到美化页面的功能。一个Web应用系统的图形可以包括图片、动画、边框、颜色、字体、背景、按钮等。图形测试的内容有：<br>（1）要确保图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间。Web应用系统的图片尺寸要尽量地小，并且要能清楚地说明某件事情，一般都链接到某个具体的页面。<br>（2）验证所有页面字体的风格是否一致。<br>（3）背景颜色应该与字体颜色和前景颜色相搭配。<br>（4）图片的大小和质量也是一个很重要的因素，一般采用JPG或GIF压缩，最好能使图片的大小减小到30k以下<br>（5）最后，需要验证的是文字回绕是否正确。如果说明文字指向右边的图片，应该确保该图片出现在右边。不要因为使用图片而使窗口和段落排列古怪或者出现孤行。<br>通常来说，使用少许或尽量不使用背景是个不错的选择。如果您想用背景，那么最好使用单色的，和导航条一起放在页面的左边。另外，图案和图片可能会转移用户的注意力。</p><h2 id="十五、业务流程测试（主要功能测试）"><a href="#十五、业务流程测试（主要功能测试）" class="headerlink" title="十五、业务流程测试（主要功能测试）"></a>十五、业务流程测试（主要功能测试）</h2><p>业务流程，一般会涉及到多个模块的数据，所以在对业务流程测试时，首先要保证单个模块功能的正确性，其次就要对各个模块间传递的数据进行测试，这往往是容易出现问题的地方，测试时一定要设计不同的数据进行测试。</p><h2 id="十六、安全性测试"><a href="#十六、安全性测试" class="headerlink" title="十六、安全性测试"></a>十六、安全性测试</h2><p>（1）<strong>SQL</strong>注入（比如登陆页面）</p><p>（2）XSS跨网站脚本攻击：程序或<strong>数据库</strong>没有对一些特殊字符进行过滤或处理，导致用户所输入的一些破坏性的脚本语句能够直接写进数据库中，浏览器会直接执行这些脚本语句，破坏网站的正常显示，或网站用户的信息被盗,构造脚本语句时，要保证脚本的完整性。</p><p>　　document.write(“abc”)</p><p>　　<script>alter("abc")</script></p><p>（3）URL地址后面随便输入一些符号，并尽量是动态参数靠后</p><p>（4）验证码更新问题</p><p>（5）现在的<strong>Web</strong>应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等。</p><p>（6）Web应用系统是否有超时的限制，也就是说，用户登陆后在一定时间内（例如15分钟）没有点击任何页面，是否需要重新登陆才能正常使用。</p><p>（7）为了保证Web应用系统的安全性，<strong>日志</strong>文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。</p><p>（8）当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。</p><p>（9）服务器端的脚本常常构成安全漏洞，这些漏洞又常常被黑客利用。所以，还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。</p><h2 id="十七、性能测试"><a href="#十七、性能测试" class="headerlink" title="十七、性能测试"></a>十七、性能测试</h2><h3 id="1连接速度测试"><a href="#1连接速度测试" class="headerlink" title="1连接速度测试"></a>1连接速度测试</h3><p>用户连接到Web应用系统的速度根据上网方式的变化而变化，他们或许是电话拨号，或是宽带上网。当下载一个程序时，用户可以等较长的时间，但如果仅仅访问一个页面就不会这样。如果Web系统响应时间太长（例如超过5秒钟），用户就会因没有耐心等待而离开。</p><p>另外，有些页面有超时的限制，如果响应速度太慢，用户可能还没来得及浏览内容，就需要重新登陆了。而且，连接速度太慢，还可能引起数据丢失，使用户得不到真实的页面。</p><h3 id="2负载测试"><a href="#2负载测试" class="headerlink" title="2负载测试"></a>2负载测试</h3><p>负载测试是为了测量Web系统在某一负载级别上的性能，以保证Web系统在需求范围内能正常<strong>工作</strong>。负载级别可以是某个时刻同时访问Web系统的用户数量，也可以是在线数据处理的数量。例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？</p><h3 id="3压力测试"><a href="#3压力测试" class="headerlink" title="3压力测试"></a>3压力测试</h3><p>负载测试应该安排在Web系统发布以后，在实际的网络环境中进行测试。因为一个企业内部员工，特别是项目组人员总是有限的，而一个Web系统能同时处理的请求数量将远远超出这个限度，所以，只有放在Internet上，接受负载测试，其结果才是正确可信的。<br>进行压力测试是指实际破坏一个Web应用系统，测试系统的反映。压力测试是测试系统的限制和故障恢复能力，也就是测试Web应用系统会不会崩溃，在什么情况下会崩溃。黑客常常提供错误的数据负载，直到Web应用系统崩溃，接着当系统重新启动时获得存取权。<br>压力测试的区域包括表单、登陆和<strong>其他</strong>信息传输页面等。</p><p>备注：</p><p>1、负载/压力测试应该关注什么</p><p>测试需要验证系统能否在同一时间响应大量的用户，在用户传送大量数据的时候能否响应，系统能否长时间运行。可访问性对用户来说是极其重要的。如果用户得到“系统忙”的信息，他们可能放弃，并转向竞争对手。系统检测不仅要使用户能够正常访问站点，在很多情况下，可能会有黑客试图通过发送大量数据包来攻击服务器。出于安全的原因，测试人员应该知道当系统过载时，需要采取哪些措施，而不是简单地提升系统性能。</p><p>1）瞬间访问高峰<br>如果您的站点用于公布彩票的抽奖结果，最好使系统在中奖号码公布后的一段时间内能够响应上百万的请求。负载测试工具能够模拟X个用户同时访问测试站点。</p><p>2）每个用户传送大量数据<br>网上书店的多数用户可能只订购1-5书，但是大学书店可能会订购5000本有关心理学介绍的课本?或者一个祖母为她的50个儿孙购买圣诞礼物(当然每个孩子都有自己的邮件地址)系统能处理单个用户的大量数据吗?</p><p>3）长时间的使用<br>如果站点用于处理鲜花订单，那么至少希望它在母亲节前的一周内能持续运行。如果站点提供基于web的email服务，那么点最好能持续运行几个月，甚至几年。可能需要使用自动测试工具来完成这种类型的测试，因为很难通过手工完成这些测试。你可以想象组织100个人同时点击某个站点。但是同时组织100000个人呢。通常，测试工具在第二次使用的时候，它创造的效益，就足以支付成本。而且，测试工具安装完成之后，再次使用的时候，只要点击几下。<br>采取措施：采用性能测试工具WAS、ACT，LR等协助进行测试</p><h2 id="十八、测试中应该注意的其他情况"><a href="#十八、测试中应该注意的其他情况" class="headerlink" title="十八、测试中应该注意的其他情况"></a>十八、测试中应该注意的其他情况</h2><p>1、在测试时，与网络有关的步骤或者模块必须考虑到断网的情况</p><p>2、每个页面都有相应的Title，不能为空，或者显示“无标题页”</p><p>3、在测试的时候要考虑到页面出现滚动条时，滚动条上下滚动时，页面是否正常</p><p>4、URL不区分大小写，大小写不敏感</p><p>5、、对于电子商务网站，当用户并发购买数量大于库存的数量时，系统如何处理</p><p>6、测试数据避免单纯输入“123”、“abc“之类的，让测试数据尽量接近实际</p><p>7、进行测试时，尽量不要用超级管理员进行测试，用新建的用户进行测试。测试人员尽量不要使用同一个用户进行测试</p><p>8、提示信息：提示信息是否完整、正确、详细</p><p>9、帮助信息：是否提供帮助信息，帮助信息的表现形式（页面文字、提示信息、帮助文件），帮助信息是否正确、详细</p><p>10、可扩展性：是否由升级的余地，是否保留了接口</p><p>11、稳定性：运行所需的软硬件配置，占用资源情况，出现问题时的容错性，对数据的保护</p><p>12、运行速度：运行的快慢，带宽占用情况</p>]]></content>
      
      
      <categories>
          
          <category> web测试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web测试总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>monkey命令集</title>
      <link href="2020/12/14/monkey/"/>
      <url>2020/12/14/monkey/</url>
      
        <content type="html"><![CDATA[<p> Monkey：（面试题  *****）<br>主要用于移动端的稳定性测试</p><p>大佬的博客：<a href="https://www.jianshu.com/p/97268b83dc1d">monkey自动化测试（1）—-命令行 - 简书 (jianshu.com)</a></p><p>adb shell monkey 100     对移动端的设备进行随机的测试</p><p>adb shell monkey  -P  包名  100 </p><p>adb shell monkey  -P  包名 -v  100 </p><p>Monkey日志的级别是通过 -v -v -v<br>-v        仅提供启动提示、测试完成和最终结果等少量信息<br>-v -v     提供较为详细的日志，包括每个发送到Activity的事件信息<br>-v -v -v  最详细的日志，包括了测试中选中/未选中的Activity信息</p><p>将日志信息打印到本机<br>adb shell monkey  -P  包名 -v   100 &gt;e:/log.txt</p><p>时间延迟（事件的延迟）<br>adb shell monkey -p 包名 –throttle 300  -v  100  &gt;e:/log.txt</p><p>adb shell monkey -pct-touch 67 -v 10   调整触摸事件的百分比<br>adb shell monkey -pct-motion 67 -v 10   调整移动事件的百分比(直线移动)</p><p>–ignore-crashes   设置后 无论是app崩溃还是移动端链接失败  压力次数会一直执行 直到结束<br>–ignore-timeouts（ANR  *****）</p><p>终极版</p><p>adb shell monkey -p com.tencent.mtaexample -s 23  –throttle 2000 –ignore-crashes –ignore-timeouts -v -v -v 100000&gt;/data/local/tmp/log.txt 2&gt;&amp;1 &amp;  </p>]]></content>
      
      
      <categories>
          
          <category> monkey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux adb 命令集</title>
      <link href="2020/12/14/linux-chang-yong-ming-ling-adb-ming-ling/"/>
      <url>2020/12/14/linux-chang-yong-ming-ling-adb-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>linux常用命令　</p><p>ls / 展示</p><p>　　cd 切换 cd.. 返回</p><p>　　mkdir  创建目录</p><p>　　touch  创建文件</p><p>　　rmdir  删除</p><p>　　cp    复制</p><p>　　mv　　移动/删除</p><p>　　vi　　  编辑</p><p>　　：wq   退出并保存  </p><p>　　pwd　　显示路径</p><p>查看文件：</p><p>　　cat　　由第一行开始显示文件内容</p><p>　　tac　　从最后一行开始显示  cat反写</p><p>　　nl　　 显示的时候展示行号</p><p>　　more  一页一页的显示文件内容</p><p>　　less   与more类似，但是比之较好的是可以向前翻页</p><p>　　head　只看头几行</p><p>　　tail　　只看尾几行</p><p>用户管理命令：</p><p>　　useradd　　添加用户</p><p>　　userdel　　 删除用户</p><p>　　usermod　　修改用户</p><p>　　passwd　　  修改密码</p><p>添加用户组：  groupadd</p><p>用于磁盘管理：</p><p>　　df　　列出文件系统的整体磁盘使用量</p><p>　　du　　检查磁盘的空间使用量</p><p>　　fdisk  用于磁盘分区</p><p>adb常用命令</p><p>　　连接虚拟机/真机后打开cmd黑窗口</p><p>　　　　adb devices　　查看设备编号</p><p>　　　　adb install+路径　　   安装apk</p><p>　　　　adb unstall　　 卸载apk</p><p>　　　　adb shell pm list packages　　罗列出所有的包名　　　　</p><p>　　　　　　　　　　　　　　　　 -s  系统包名</p><p>　　　　　　　　　　　　　　　　 -3  三方包名</p><p>　　　　adb shell dumpsys cpuinfo　　查看当前移动端cpu使用率</p><p>　　　　adb shell dumpsys cpuinfo -包名 　查看当前App的cpu使用率</p><p>　　　　adb shell getpop | findstr dalvik　　查看本机内存使用率</p><p>　　　　adb shell dumpsys meminfo +包名 　查看当前App内存使用率</p><p>　　　　adb shell dumpsys activity I findstr “mFocusedActivity”　　查看当前App的包名以及启动项</p><p>　　　　adb logcat　　查看手机日志</p><p>　　　　logcat -v time prosess &gt;C:/log/xx.txt　　指定设备进行打印</p><p>　　　　V —— Verbose（最低，输出得最多）<br>　　　　D —— Debug<br>　　　　I —— Info<br>　　　　W —— Warning<br>　　　　E —— Error<br>　　　　F —— Fatal<br>　　　　S —— Silent（最高，啥也不输出）</p><p>　　　　adb logcat *:W 过滤日志（含W以及W以上的日志）</p><p>adb不常用命令（面试用）</p><p>　　　　adb start-server / adb shell 　启动adb服务</p><p>　　　　adb kill-server　　关闭adb服务</p><p>　　　　adb version　　　　查看当前App版本</p><p>　　　　adb get-serialno　　获取手机序列号</p><p>　　　　adb shell wm size　　查看手机屏分辨率</p><p>　　　　adb shell cat/proc/cpuinfo　　显示手机的cup信息</p><p>　　　　adb shell getprop ro.product.model 　 查看手机的设备型号</p><p>　　　　adb shell cat /sys/class/net/wlan0/address 　　获取手机的mac地址</p><p>　　　　adb shell pm list packages 　　显示手机里面所有应用的包名</p><p>　　　　cd xx文件　　进入某个文件</p>]]></content>
      
      
      <categories>
          
          <category> linux adb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux adb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏签到系统测试点</title>
      <link href="2020/12/14/you-xi-qian-dao-ce-shi-dian/"/>
      <url>2020/12/14/you-xi-qian-dao-ce-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-测试点分析"><a href="#1-测试点分析" class="headerlink" title="1.测试点分析"></a>1.测试点分析</h2><h3 id="1-查看页面UI："><a href="#1-查看页面UI：" class="headerlink" title="1.查看页面UI："></a>1.查看页面UI：</h3><p>​        是否美观，</p><p>​        按钮是否正常</p><p>​        可签到</p><p>​        未签到</p><p>​        累计签到多少天</p><p>​        能否补签</p><h3 id="2-性能："><a href="#2-性能：" class="headerlink" title="2.性能："></a>2.性能：</h3><p>​        响应时间，点击签到多久可以响应成功</p><p>​        点击签到，如果失败会不会提示</p><h3 id="3-功能："><a href="#3-功能：" class="headerlink" title="3.功能："></a>3.功能：</h3><p>​        全部签到成功之后天数是否清零</p><p>​        多次点击签到按钮</p><p>​        每天签到是否天数叠加</p><p>​        晚上23:59:59，一秒钟后重登游戏，是否可以继续签到</p><p>​        一天内登录多次游戏，是否可以继续签到</p><p>​        每天第一次登录游戏，签到页面是否弹出，第二次登录游戏，是否不弹出</p><h3 id="4-兼容性："><a href="#4-兼容性：" class="headerlink" title="4.兼容性："></a>4.兼容性：</h3><p>​        ios,安卓手机，电脑端是否都能用</p><h3 id="5-易用性："><a href="#5-易用性：" class="headerlink" title="5.易用性："></a>5.易用性：</h3><p>​        页面是否通俗易懂，符合用户使用</p>]]></content>
      
      
      <categories>
          
          <category> 测试点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目上线后出现问题，该如何解决？</title>
      <link href="2020/12/14/xiang-mu-shang-xian-hou-chu-xian-wen-ti-ru-he-jie-jue/"/>
      <url>2020/12/14/xiang-mu-shang-xian-hou-chu-xian-wen-ti-ru-he-jie-jue/</url>
      
        <content type="html"><![CDATA[<p><strong><em>首先测试人员可以做的是重现这个问题并及时反馈给开发人员，找到解决方案进行修复。</em></strong></p><p>​    如果问题只在线上才出现，测试环境重现不了，那么可能是版本或环境配置的问题；</p><p>​    如果问题不仅线上能重现，测试环境也存在，那么很有可能是测试人员在测试过程中未发现的Bug。</p><p><strong><em>开发人员修复Bug之后，测试人员需要反思。</em></strong></p><p>​    若是由于疏忽造成测试用例执行遗漏，测试人员需要在下次执行测试的过程中避免这样的情况。</p><p>​    若是由于用例评审的不严格、中途需求变更或者某些其他因素造成的测试用例覆盖不全，测试人员需要补全测试用例。</p><p><strong><em>在测试过程中遇到未发现的Bug，测试人员不要自怨自艾，</em></strong></p><p>​    也不要像没回事儿一样，需要正确对待“线上Bug”、汲取经验教训、不断提高测试能力。</p><p>​    测试人员需要不断学习，不断扩充，掌握测试工具、提升测试技能，从而设计出更全面的测试场景和测试用例。</p>]]></content>
      
      
      <categories>
          
          <category> 项目上线后出问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目上线后出问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发流程</title>
      <link href="2020/12/14/xiang-mu-kai-fa-liu-cheng/"/>
      <url>2020/12/14/xiang-mu-kai-fa-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="一个WEB应用的开发流程"><a href="#一个WEB应用的开发流程" class="headerlink" title="一个WEB应用的开发流程"></a>一个WEB应用的开发流程</h1><p>先说项目开发过程中团队人员的分工协作。</p><h2 id="一、人员安排"><a href="#一、人员安排" class="headerlink" title="一、人员安排"></a>一、人员安排</h2><p>　　毕业至今的大部分项目都是独立完成，虽然也有和其他同事协作的时候，但自认为对团队协作的了解和认知都还有所欠缺。很清楚团队协作的重要性，但尚未有很好的机会在相对成熟的团队中锻炼实践。</p><p>　　先抛开<strong>软件开发</strong>团队中人员的具体安排不讲，单纯的看软件开发工作的分工。在上面设想的开发架构中，宏观上可将一个项目划分为前端、程序、<strong>数据库</strong>三个模块。由此可推导出团队中需要的成员：美工、程序员和项目经理。</p><p>　　认为理想的软件开发团队由四个专业技能过硬的成员组成：一个美工，熟悉UI的设计并具备将效果图转换成前端页面的能力，也就是得同时精通PhotoShop、HTML、CSS、jQuery等前端知识；一个程序员，熟练掌握代码的编写重构；一个项目经理，具备<strong>需求分析</strong>的能力、数据库设计维护的能力、架构设计的能力、程序编写的能力、前端样式脚本编写的能力，最重要的是对业务流程有精准的把握；一个部门经理，和前三位不一样，部门经理只具备领导能力即可，他是兼职，不需要把全部时间投入到团队中。</p><p>　　大部分中小型项目可以由这样的四人团队完成，可如果项目较大，已经大大超出了四个人可完成的工作量，可以再加一个前端开发人员。也就是说两个前端开发者，一个负责UI设计，做出完整的效果图，这个人的设计功底应该比较强；一个负责将效果图转换成页面，并完成样式、脚本等的编写，这个人对前端样式脚本的掌握应该比较熟练。同时程序员的数量也可以增加，可以根据业务将软件划分成不同的功能模块，按照功能模块进行工作量上的划分，交给不同的程序员完成。也可以根据程序架构进行工作量上的划分，实体由谁来负责、接口由谁来负责、应用层由谁来负责、业务逻辑层由谁来负责、数据访问层由谁来负责，等。无论项目如何庞大，这个项目的整体设计师只能有一位，那就是项目经理，负责UI的设计者，最好也只有一位，这样可以确保整个项目设计的完整性、协调性。</p><p>　　也没有更大规模项目的开发经验，如果成员质量可靠的话，四个人的开发团队足以应付大部分Web业务系统的开发。一直主张，在可能的情况下，团队中的成员质量应该越高越好，而团队中的成员数量则应该越少越好。因为四人以上的团队，沟通成本会随着人员数量的增长指数增长，工作效率也会随着人员数量的增长指数下降。</p><p>　　团队成员中沟通的问题稍后介绍，先来讲下团队各成员的工作重心。项目经理负责数据库的详细设计、程序架构和前端的宏观设计，把控全局且必须参与到具体的开发工作中。项目经理是整个团队成员中工作量最大的一位，必须是全职，在一个项目完工之前，他不应该去做与这个项目无关的任何其它工作。部门经理主要负责跟踪项目开发进程，督促项目经理和团队的工作，并满足项目经理调用公司各种资源的需求。部门经理可以定期组织会议听取项目经理和团队针对项目的工作汇报，也可以提出自己的部分意见，但对于项目的开发实现没有任何的决定权。部门经理的责任最大，但日常工作量并不多，因为他无需涉及具体的项目开发工作。</p><p>　　对项目的最终展现有决定权的只能有两个人，一个是客户，一个是项目经理。客户是第一位的，提出需求；项目经理是第二位的，决定此需求的实现方式。除此之外，不应该有其它任何人干涉项目的具体工作。尤其是管理者，比如这里的部门经理。部门经理必须要跟踪并督促项目的进展，但万万不要干涉具体的项目开发设计。</p><p>　　负责整体设计的人一定要参与到开发工作中，谁设计的谁就要参与到具体开发中，不懂开发不想开发开发不了就不要参与设计。有些懂<strong>技术</strong>的管理者喜欢自己设计项目，然后交由下面的人去实现自己的设计，这种看似没有问题的分工方式实际上是最致命的。管理者喜欢这样做，是想让这个项目按自己的理念完成，让这个项目处于自己的掌控之中，但同时，具体的开发工作又是非常繁琐耗费精力的，这部分工作全交给下面的员工去做，自己坐享其成。这样分工的问题在哪里呢？坦白的讲，很多管理者对技术的掌握、对业务的了解远不如基层员工，由他来负责设计，设计本身可能就是有问题的。更坏的情况是，不负责整个项目的整体设计，整体设计由项目经理来做，但关键性的业务，非要自己来设计。项目经理、程序员在去实现这样的设计时，会遇到很多问题，有的是在开发过程中就做不下去了，有的勉强开发出来，却给后期的扩展维护更改埋下了巨大隐患，一个失败的项目也就这么出来了。</p><p>　　在法律术语中有“谁主张谁举证”的说法，在软件开发中也应该有一条类似的术语，“谁设计谁开发”。你设计却让别人去开发同你主张却让别人举证一样荒唐。“谁设计谁开发”可以有效避免上面提到的问题，如果项目设计者知道由自己去参与实现自己的设计，那他在设计时就会慎重许多。如果他自己开发都无法实现自己的设计，那别人又能如何呢？这样责任就会归咎到根源上。如果真的形成这样一条铁律，或许就不会有人去轻易的干涉设计工作，因为成本太高、代价太大。</p><p>　　之所以花这么多时间讲管理者、设计者、开发者之间的分工，是因为过去经手的诸多项目中有不少都是毁在了管理者的干涉上。但是，人员分工方案和“谁设计谁开发”原则只是一种理想的情况，现实的工作中，怕很难能做到这点。团队之间需要一个相互角逐的过程，每个人都在往里面施加自己的影响力，最终胜出的那个人才可能有最终的话语权。有人的地方就会有江湖，有江湖的地方就会有争斗。</p><p>　　曾多次向同事讲过《人月神话》中提到的巴比伦塔的故事，上帝为了阻止人们建造巴比伦塔而创造了不同的语言，使人与人之间无法沟通，最终导致此工程的失败。团队协作中最核心的问题就是沟通。适时的进行定期的、不定期的会议对团队人员之间的相互磨合至关重要。《动物世界》中有<strong>记录</strong>，狼群即便是在非守猎的闲暇时间也会定期组织聚会，增进感情、明确组织中的成员地位。人也应该是一样的。</p><p>　　人与人间的沟通效率直接决定着整个团队的工作效率。在上面提到的对软件开发团队的成员划分中，项目经理对数据库、程序、架构的设计要和程序员对接，项目经理对界面、前端的设计要和美工、前端开发者对接，项目经理对全局的设计、比如前端脚本和后端程序的互调要和所有人对接。UI设计者要和将UI转换成具体页面并编写相应脚本的前端人员对接。前端人员要和程序员进行对接。项目经理是所有沟通渠道的枢纽，责任重大。</p><p>　　人不是机器，都会有情绪，有好恶，这种好恶情绪会导致团队各成员之间互相合得来或合不来，这是致命的。在团队，应该杜绝个人情绪，抛开喜怒哀乐只就事论事就工作论工作。为了保证沟通渠道的畅通，定期的会议是必须的，项目开发过程中，也可根据实际情况增加临时会议。团队初建之时，为了增进相互了解，定期的会议应该是相对频繁的。团队成型之后，定期的会议可以适当（是适当）减少，而着重于增加沟通效率。既然都相互熟悉了，那就把沟通成本降到最低。除了会议，也可以尝试进行其它的团体活动，比如适时的户外活动、定时聚餐等等，以增进相互了解。团队的形成，终需要时间的磨合，而如何把这个磨合时间降到最底，团队带头人的责任最大。在团队中，个人能量的大小不是最重要的，重要的是整个团队能量的大小。成然，团队中每个成员的质量在一定程度上决定着整个团队的质量，可如果每个成员仅仅在技术上优秀，互相之间却不沟通协调、甚至在工作上为一己之私勾心斗角，那这个团队永远不会是一个成功的团队。团队中的每个成员都应该拥有大局观念、团结意识，这才是第一位的。</p><p>　　锻炼团队最有效的方式和锻炼个人的一样，还是实战，如果不考虑人员变动，三个项目过去，团队自然可以成型。</p><p>　　认为理想的WEB应用程序开发框架是自己先前设想的那种，前端、程序、数据库之间互相分离，以上关于团队成员的划分安排即是在这种开发框架下设定。如果不是这种开发模式，比如用了服务器控件、比如用的是其它编程语言、比如不支持多数据库，甚至是非WEB应用项目的开发，团队成员划分方案大致类似。</p><h2 id="二-了解需求"><a href="#二-了解需求" class="headerlink" title="二.  了解需求"></a>二.  了解需求</h2><p>　　虽然在本文档中对软件开发的环节逐个分别进行讨论，但这并不是说各个环节之间是完全隔离的。正如下面的图中所绘，了解需求、需求分析、文档设计等环节之间都是有交集的，而非孤立的。在了解需求的时候项目经理的脑海中其实已经开始进行需求分析、项目设计了，在需求分析的时候项目经理的脑海中也已经开始进行项目设计了，文档的整理也都是在这些环节中逐步先成型于脑海，最后将其表述在WORD文档中。</p><p>![项目流程图](D:\learning materials\cs\img\项目流程图.png)</p><p>　　在第二次世界大战中，美国陆军兵器修理部首创5W2H分析法，又叫七何分析法，这对于决策和执行性的活动措施非常有帮助，也有助于弥补考虑问题的疏漏，此分析法非常适用于软件开发前的需求了解、确认、分析。2H，How to do、How much实际就是就是对需求进行分析的过程，这个会在下个章节中介绍。5W，What、Who、Why、Where、When才是了解需求时要向目标对象确认的问题，是本模块要介绍的内容。</p><p>　　在软件需求了解过程中，对要思考的5W问题进行了新的排序。</p><h3 id="步骤（1）做什么（What）？"><a href="#步骤（1）做什么（What）？" class="headerlink" title="步骤（1）做什么（What）？"></a>步骤（1）做什么（What）？</h3><p>　　第一个要搞明白的，这是什么？要实现什么功能？必须要实现的功能有哪些？不确定是否要实现的功能有哪些？核心的功能有哪些？是WEB应用系统还是桌面应用程序？是注重处理业务实现还是注重信息展示还是两者兼有？对于数据库有没有特别的要求？有没有什么规范、有的话是什么？</p><p>　　初次了解，就应该用草纸给出一个大致的列表，列出开发要实现的核心功能。What是5W的核心，尽可能详细的弄明白自己将要开发的是什么样的软件非常重要。不过，也别期望经过些简短沟通分析就能把所有细节确定下来，完整需求的确认是贯穿好多个环节的。</p><p>　　以往的项目中，甚至有到开发阶段才发现自己对需求的理解有误。设计都已经完了，都已经开始开发了，出现这样的问题自然会非常麻烦，但也应该有相应的解决措施。也正因为如此，在了解需求时才不得不仔细，尽可能的和项目负责人多会面多沟通以搞清楚这个What。</p><h3 id="步骤（2）-谁（who）？"><a href="#步骤（2）-谁（who）？" class="headerlink" title="步骤（2） 谁（who）？"></a>步骤（2） 谁（who）？</h3><p>　　项目的需求来自于谁（哪里）？项目的使用者是谁？项目的沟通协调人是谁？项目的检验者是谁？项目的主负责人是谁？</p><p>　　就曾遇到过的情况，项目的开发需求一般来自于四种目标对象：</p><p>　　A、客户。这是最常见的情况，因为单位的客户有某一方面的具体需要，才要做这个项目。只要客户那边负责项目沟通协调的是个明白人，后面一切都好办。而且就过去遇到的情况，协调人一般都是基层员工或基层员工的小领导，对现实的需求也都比较清楚，这样自己的工作做起来还是比较容易的。</p><p>　　B、自己。这是特殊情况，比如提到的权限管理系统，是因为自己的兴趣，觉得有必要做个什么项目。自己想要的东西，当然自己最清楚了，这本来是了解需求的最简单情况，但因为自己想要的总是太过完美，总是想开发一个尽乎完美的产品，所以其实这个才是最难的。</p><p>　　C、市场。更多的像是在说<strong>互联网</strong>产品，既然是来自于市场，那就面临着诸多的不确定性。你的使用者都是泛泛的用户，没有非常明确的需求。只能是自己通过可能的渠道去了解，并参考网络中已有的资源，来大致确定一种需求，再进行开发。如果项目经理的能力足够，又没有来自领导层的不靠谱干预，这个也是有可能开发出实用性产品的，不过，不容易。</p><p>　　D、领导。公司的领导层凭空想要这么一个东西，比如别的公司有病理心电，我们没有，你们做一个。这还不是最麻烦的，更麻烦的是凭空想象这么一个产品还在凭空规定一种技术，要求必须这样这样开发，要求必须按他的想法来做。曾经说过，见过的同行中60%以上的人不识货，见过的客户中80%以上的人不识货，见过的领导中100%的人不识货，真的不是夸张，所以这是四种情况中最麻烦的一种。也可能是被糊涂的领导折磨过敏了，总之，以后如再遇到这种情况，一定做好心理准备，如果发现领导是自己见过的糊涂的那种，尽可能的想办法把活推给别人。</p><p>　　并不是做互联网产品出身，所以对第三种情况不敢妄谈，但并不认为自己对互联网产品的了解就不如企业内部应用系统。也一直希望手里的系统都能像互联网产品一样易用稳定，这是自己追求的产品目标。</p><p>　　项目的使用者肯定不是唯一的，结合上面的What，应该弄明白会有哪几类使用者，每类使用者之间可使用的功能有什么区别，每类使用者的人数大致有多少，哪一类是系统的主要用户，这对于设计阶段划分系统角色非常重要。</p><p>　　因为自己的工作，项目开发需求大都来自于A情况，也就是实实在在的客户。这种情况，项目最终的成败不仅仅是由产品的好坏来决定。项目最终能否顺利验收，说白了，也就是项目校验者、主负责人的一句话。 所以应提前弄清楚项目的协调人、校验者、主负责人，这对于后期工作也是至关重要的。</p><h3 id="步骤（3）何地（where）？"><a href="#步骤（3）何地（where）？" class="headerlink" title="步骤（3）何地（where）？"></a>步骤（3）何地（where）？</h3><p>　　开发完成的项目最终要部署在什么地方？环境是内网还是外网？什么<strong>操作系统</strong>什么数据库什么环境可变动否？确定的还是不确定的？</p><p>　　比如现在开发的远程医学平台，在每个省份每个客户那里的部署环境都不大一样，尤其是网络环境。有的是要部署在内网，有的是要部署在外网，有的是要求内外网都可以访问。虽然最终的网络环境对开发工作影响并不大，但还是提前知道有点心理准备为好。操作系统一般都是<strong>Windows</strong>的，数据库一般是<strong>Oracle</strong>和 SQLServe，这些要求一般都是由开发者来提，不过也有客户为了跟他们内部的系统保持一致直接要求必须用什么库。</p><p>　　对于不确定的部署环境，开发者只能提前做好多个准备，不过这个问题不大。了解清楚Where，主要是为后期项目的部署做好准备。</p><h3 id="步骤（4）何时（when）？"><a href="#步骤（4）何时（when）？" class="headerlink" title="步骤（4）何时（when）？"></a>步骤（4）何时（when）？</h3><p>　　目标对象要求多长时间完成工作？自己初步估计需要多长时间可以开发完成？目标对象的可承受时间下限是什么？</p><p>　　目标对象可能是客户、自己、市场、领导。对于客户，他们当然是要求愈快愈好，其实大部分情况他们自己也说不清楚具体的时间，只是希望今天提出要求，明天就能出来，这当然是不可能的。要了解的是他们能承受的上限，开发时间千万不要越过这个上限。</p><p>　　可以在计划上对项目进行分期，一期实现核心的功能，先上线运行，后面再逐步完善。想一次性完美实现所有的需求，不但时间不允许，怕开发人员的能力也是不够的。</p><p>　　先出来这么一样产品，让客户先用着，后面再一点点完善。说的直白点，就是敏捷开发、频繁迭代，这也是好多领导多次要求的开发方式，但其实这样做的问题非常多，而且这种方式非常不适合项目的目标对象是客户的情况。</p><p>　　先期的产品定然有瑕疵，匆忙上线只会让客户对这个产品各种不满意，而且客户一但看到这个产品，那怕明知它是先期的，也会提出各种各样的更改要求。这样，忙于应付客户更改要求的开发人员哪里还有时间继续未完成的开发工作？所以前期应尽可能的和目标对象角逐，把时间拖到最长，以尽可能多的完成这个产品，完成的差不多时再拿给用户看。后期的产品已经很完善了，如果功能、效果图又都在前期做过详细确认，这时客户的更改要求应该会相应少些，既便很多，不涉及根本功能的变更，开发者要做的工作也就相对容易了。</p><p>　　目标对象是领导和市场的处理方式类似，如果目标对象是自己，开发工作一般都只能抽业余时间，也应该有非常明确的时间底线才好，不能总是拖着。所有的工作，抛开时间来谈都没有任何意义。</p><p>　　在这里整理软件开发的完整流程，就是想将项目周期压缩到最低。因为目标对象的耐性不是无限的，可以尽量拖着以把产品做到最好，但拖的时间越长，自己面临的各方压力就会越大，如果达到临界值，项目也就报废了。这种情况也是出现过很多次的，不能不引起警觉。</p><h3 id="步骤（5）为什么（why）？"><a href="#步骤（5）为什么（why）？" class="headerlink" title="步骤（5）为什么（why）？"></a>步骤（5）为什么（why）？</h3><p>　　Why应该是贯穿在前四个W中的，每得到一个W的答案，都应该多问一句，这样做的目的是什么？为什么要这样做？不这样做不行吗？用另外一种做法行不行？Why提供了一个更好更深入了解需求的机会。</p><p>　　从项目启动开始，手里边就应该有一支铅笔、一个钻笔刀、几张白纸，以便随时把自己的思路记录下来。和目标对象沟通了解需求时应该注意积累一些小的技巧。在会面时近可能的用<strong>手机</strong>进行录音，以方便自己后期查对。备好纸笔，对关键性问题进行记录。见面时注意把控整体的交流氛围并注意一些沟通技巧，如果是相对正式的会谈大家应该提前互相预约一下，让双方都有些准备，自己要提前准备好要问的问题。首次见面，应该互留下联系方式，以方便后面随时沟通。如果能深入到前线，和目标对象天天照面，那就更好了，可以随时对需求了解确认，这样就很少出问题了。还有，如果可能的话，让目标对象提供一些和项目相关的书面材料，表格、文档、手册、宣传材料。不管有用没用，先搜集过来再说。</p><p>　　无论准备的有多充分，也不能祈求一次简单的会面、一次简单的沟通就能把所有的需求了解清楚。你能理解的清楚，目标对象却未必能一次就把自己想要的说清楚，有时甚至会遗忘掉关键部分。沟通、了解、分析、确认是一个循环的过程，就像上面的流程图中所绘，跟客户的沟通确认是贯穿整个开发前的阶段的，甚至会延续到开发之中、开发之后。</p><p>　　了解需求之后，可以落实的是，初步的沟通笔记、录音资料，目标标对象提供的相关文档资料，脑海中本项目的早期零散琐碎片段。</p><h2 id="三-需求分析"><a href="#三-需求分析" class="headerlink" title="三 需求分析"></a>三 需求分析</h2><p>　　对需求进行分析的过程，就是将早期进行需求了解时搜集到的资料、脑海中的零散碎片进行整理的过程，最终以文档的形式将需求具体化下来。</p><p>　　需求分析时，首先将手里面掌握的零碎的资料做下整理，把用户提到的要求再梳理一下，用草纸做下大致的记录。然后考虑前面提到的2H的问题。</p><h3 id="步骤（6）-怎样（How）？"><a href="#步骤（6）-怎样（How）？" class="headerlink" title="步骤（6） 怎样（How）？"></a>步骤（6） 怎样（How）？</h3><p>　　实现这样的需求应该怎样做？有没有技术难点、可否实现？业务流程应该是怎样的？数据库如何设计？总的架构如何设计？框架如何设计？前端如何设计？能安排给谁来做各模块？目前的需求有哪些模糊的部分需要再次确认？</p><p>　　考虑How的问题，并不是说现在就要给出一个详细的实施方案，而是说要对目前掌握到的这个初步需求进行分析，发现其中的实施难点、需求模糊点。对于难点，考虑下其可否解决、成本如何；对于模糊点，标记出来后面再次确认。</p><h3 id="步骤（7）多少（How-much）？"><a href="#步骤（7）多少（How-much）？" class="headerlink" title="步骤（7）多少（How much）？"></a>步骤（7）多少（How much）？</h3><p>　　这个项目的繁杂度如何？做的话时间成本、人力成本是多少？项目的收益是多少、对单位对自己对现在对将来有什么益处？对单位来讲有没有市场？对个人来讲能不能锻炼自己巩固提升自己的位置、还是仅仅徒增麻烦？</p><p>　　抛开时间来讲，所有的工作都没有任何意义。抛开成本来讲，工作更是没有意义。这里的成本，主要是开发中涉及的人月的问题，需要多少人多少时间。项目的收益，先从个人来讲，再从公司来讲，对于自己和公司都没有任何好处的项目，尽可能的不要接手。</p><p>　　对手中得到的书面资料及用户的录音资料进行分析整理，把核心部分条理化，确认的和模糊的分别标记。和目标对象保持沟通，把模糊的部分清晰化。</p><p>　　早期的需求分析，我们至少要得出下面四个问题的的初步答案。</p><p>　　第一个，初步整理后的需求确认书。在对了解需求时的资料进行梳理后，整理出一份前期的需求确认书。至少要把核心需求列清晰，以文档的形式具体化下来，并和客户保持非正式沟通、确认。这样的沟通确认应该是多次的、循环的，以对这个确认书进行多次的完善，逐步的将其具体化。</p><p>　　第二个，可行性研究。对这个初步的需求确认书进行可行性研究，用户的要求是否可以实现。如果不可以，为什么？难点在哪里？如果可以，难度系数如何？从个人来讲、从单位来讲付出收益间是正值还是负值？在你看来，结合你当前的时间安排，这个到底值不值得抽出时间来开发。</p><p>　　第三个，业务流程。就自己了解到的用户需求，实现这些需求的业务流程是怎样的。核心业务有哪些？核心业务的流程是什么？附属业务有哪些？附属业务的流程是什么？比如要给犬只办卡、比如要进行会诊、比如要交费、比如要统计、比如要管理网站展示信息、比如要进行权限管理，等等，大致的流程是怎样的？这些要和用户确认清楚。更详细的流程，会在设计阶段具体化下来，这里必须得出初步的流程。</p><p>　　第四个，开发成本。如果说这个项目可以开发，值得开发，业务流程也理得差不多了，那需要多少人、具体到是谁？需要多少时间、最少要多少时间、最长要多少时间？你个人以及公司能否持续投入这样的时间和人力来做这项工作？</p><p>　　早期分析之后，即便得到的结论是不值得开发，或者说要耗费的成本很多、公司可能无法投入这些成本，个人恐怕也没有最终的决定权。项目是否要开发，只能说明自己的意见，会和最上面的领导层或者商务部门间进行角逐，但拍板的还是大BOSS。如果说非要开发自己觉得不能开发的项目，或者说对自己来讲不值的项目，这时能做的只有明哲保身了，以手里的其它重要工作为借口把工作推给别人。如果推也推不掉，那就坦然接受了，全力去做这个不可改变的事情，力求把损失降到最低而把可能的收益最大化。</p><p>　　在整个的需求分析过程中，在早期的需求确认书出来之后，我们和目标对象的沟通应该是持续的。在最后应该和目标对象进行一次正式详细的沟通，把早期的需求确认书、早期分析之后零散的碎片进一步整理，然后再出一份正式的需求确认文档，交由用户签字确认。这份文档，就是目前可得到的最详细的需求确认文档。</p><p>　　在这个需求分析、对需求反复确认的过程中，脑海中其实已经开始进行项目的初步的设计才对。流程、架构、界面、数据库、程序、前端、业务、权限等等片段，已经开始出现在脑海中了。需要哪些人来做哪些模块、各模块大致要花多少时间、哪些功能哪些环节可能会出现问题、项目开发之中开发之外的阻力可能会有哪些？这些自己心里面都应该有数了，只是，仍然没有具体化下来，而这个具体化的过程，就是项目设计的过程。</p><h2 id="四-项目设计"><a href="#四-项目设计" class="headerlink" title="四 项目设计"></a>四 项目设计</h2><p>　　经过需求分析之后，我们手里已经有了一份比较明确的需求确认书，同时项目经理的脑海中也有了一个模糊的模型。项目设计环节，就是要以这份需求确认书为基本依据，和客户继续保持沟通，将脑海中的项目模型具体化下来，落实成效果图、CDM、PDM及开发文档等电子资料。</p><p>　　一直在讲，无论到哪个环节，都不敢说需求已经全部确认下来。人的时间和精力是有限的，但客户的需求却是无限的，哪怕仅仅针对当前的项目。我们能做的不是把客户的需求全部了解清楚，而是把了解到的需求搞明白、弄清楚，不要领会错了。对于了解的需求，可以少些，但不能出错。了解错了，设计就会出错，开发就会出错，一错全错。</p><p>　　项目设计阶段，要考虑的主要有七个问题。第一个是业务流程，核心业务、附属业务的流程各是什么样的；第二个是前端，包括效果图、页面、脚本、样式；第三个是数据库，把业务流层转换成表结构、表与表间的关系；第四个是开发用什么样的架构，前端、程序、数据库之间以什么方式对接；第五个是程序，既包括前端脚本的程序也包括后台的程序，程序的架构是什么样的，工厂模式、三层、还是其它；第六个是技术关键点，比如有的要用到读卡机等外接硬件、比如要放在触摸屏上、比如要有视频功能、比如要读取影像文件，这些特定的技术点如何攻破。第七个是人员安排和时间结点，具体到哪个人来做哪项工作，每项工作的时间节点是什么。</p><p>　　业务流程是我们在需求分析过程中就已经开始确认的，但这里要尽一步具体化。拿起手里的铅笔，把项目中的所有业务列举出来，再把每个业务的流层图画出来。反复检查这些流程图，检查业务的每一个环节，并跟客户沟通确认。当所有的流程图可以无误的表述各个业务时，我们的设计就已经成功了一半。</p><p>　　画流程图的过程，就是在脑海中模拟使用要开发的软件的过程，不过这时的软件还在虚无缥缈之中。在我们的脑海中虚拟出一个大工厂，但里面什么也没有，尝试着走入这座工厂去完成自己的任务——也就是客户提出的需求。为了实现需要的功能这里可能要建一个车间，然后思考车间应该有多大、应该建成什么样子的？为了完成要实现的功能这里应该放置一台机器，这台机器应该如何安放、用来制造什么物质？就这样的自由组合拼接，直到这个工厂可以实现我们提出的所有的功能、完成我们所有的业务流程。然后继续在脑海中模拟使用这个工厂，一遍又一遍的走我们的业务流程，直到确认每个环节都不再出现问题，都可以应付现实的需求。在这个过程中，业务流程中不合理部分会被修改或剔除，我们的流程会更趋于，同时我们要开发的软件也已经开始成型。</p><p>　　在梳理这些业务流程的时候，或者说在建工厂的时候，脑海中应该已经开始考虑界面部分如何实现了，还是用手里的铅笔，把界面的草图画出来。每个业务的每个环节，在前端如何展现？以什么样的方式最有特点、最绚丽出众、最易于人机交互？只是，项目经理也只能给出一个大致的草图，具体的设计实现还是由美工人员来完成。</p><p>　　外观界面是项目给人的第一印象，站在客户的角度来讲很重要。就像一座房子，你用的钢筋混泥土的质量再好，入住的人是看不到的，可如果装修的很奢华，那给人的第一印象就是这房子很高大上。程序员一般容易轻视界面的重要性，觉得这不过是一幅皮囊，只要架构足够稳定，界面再怎么绚丽，也不过是是增删改查几种动作的操作方式不同而以。这样想也无可厚非，说明项目开发团队中每个人的关注点不同，但项目经理应该有全局关念，要清楚的知道每个部分的轻重。在不同的需求、不同的客户、不同的领导、不同的时间、不同的外部状况下，各部分的轻重缓急并非是一成不变的。</p><p>　　数据库的设计跟界面草图的设计几乎同步，业务流程分析完毕、界面草图绘制完成，实现这些业务用到哪些表就很明确了。还是用手中的笔，把要用到的表列出来，把每张表的关键字段列出来，把表与表间的关系标注出来。从其功能上来讲，数据库就像工厂的仓库，但对软件设计者而言，数据库更像是一栋楼房的地基，直接决定着整个项目的稳定性。</p><p>　　有人说数据库难以设计，其实难的并不是数据库的设计，而是业务流程的梳理。再复杂的业务，只要理得清，表现在数据库中，无外乎是表与表间的三种关系：one-to-one、one-to-many以及many-to-many。更进一步的，many-to-many实际上就是两个one-to-many。对于核心业务部分尚不能明确表与表关系的，能一对多就不要一对一，能多对多就不要一对多。这样开发的复杂度会增加，却消除了后面可能的修改扩展的隐患。 “刻削之道，鼻莫如大，目莫如小。鼻大可小，小不可大也；目小可大，大不可小也。举事亦然。为其后可复者也，则事寡败矣。”说的就是这个道理。对于非核心业务也不能明确关系的，可根据实际情况，综合考量开发实现的烦琐程度及未来的可变性再做决定。</p><p>　　当业务流程、前端界面、数据库的草图出来，就开始考虑项目的整体架构、前端脚本和后台程序的局部架构。前端和程序之间通过何种方式互调？程序和数据库之间以什么方式对接？前端脚本的代码如何编写？后台程序如何设计可以把代码重复率降到最低、把程序的稳定性、可调整性抬到最高？</p><p>　　类似于表现在数据库的三种关系，再复杂的业务，表现在具体的前端、程序中，无外乎是四种动作，对数据库操作的四种动作：增（Add）、删（Delete）、改（Update）、查（Select）。更进一步的，四种动作其实就两种：读和写。查为读，增、删、改为写，读写动作的操作频繁度比例大约为十比一。</p><p>　　界面、页面、样式、脚本、程序、权限、数据库、整体架构、局部架构，自己想要的到底是什么样子的？发挥好高级语言封装、继承、多态的特性，使架构和程序更加的安全、易用、稳定、高扩展、高内聚、低耦合且功能更强大。在开发过程中，应该把自己遇到的暂时不好解决的问题及一闪而过的项目灵感等进行记录，然后在后面的修改扩展中或者是下一个项目的开发中，吸收优秀的处理经验、竭力避免已经出现过的问题。只有通过这样的反复积累，自己在开发细节上的处理才会日趋完善。</p><p>　　项目设计就是给出这个项目的实施方案。在设计的过程中，有可能会发现一些业务之外的技术难点，这些技术难点大都是之前未曾遇到过的或者是遇到过未曾完美解决的。比如前面提到的视频、影像及外接硬件等，这些技术难点如果攻不破，项目肯定也没办法完成。对于这些技术难点，应该额外分配人手专门对其研究、评估，这个也马虎不得。对于特定的项目，个人比较偏向于用开源软件解决这些特定的技术点，比如处理网页视频通信的有WebRTC、OpenMeetings，处理影像的有dcm4chee等等。不过这样做的问题也不少，如果开源产品不成熟，研究配置起来是非常耗时的，而且后期的更改维护几乎是不可能的，因为更改开源产品的源代码代价很大，相较之下反不如自己研究开发呢。对于公司通用的项目，遇到相应的技术难点，肯定是要专门分配人手研究的，比如有些公司本身就是做PACS的，那影像读取部分自然要掌握核心代码。</p><p>　　业务流程的草图出来后，多次检查有无遗漏环节，并和目标对象循环沟通确认。然后把根据业务流程图绘制的前端界面草图交给UI设计师，并把想法告知，由其用PhotoShop将草图具体化成效果图，这个阶段，仍然和目标对象保持沟通。效果图出来后，找目标对象确认，并再次确认需求分析、业务流程有无遗漏、有无错误。经过客户、UI设计师、项目经理之间的反复沟通、反复确认、反复修改之后，出来一份最终的效果图。然后项目经理根据效果图之后更加完整的需求把数据库草图具体化下来，用PowerDesigner设计出相应的CDM图、PDM图，并用此工具整理出完整的数据库文档。这样前端界面和数据库的设计就算完成了。后面就是考虑程序和架构的具体实现方式了。</p><p>　　最后应该考虑的是人员安排及开发周期问题，具体到团队中的谁、要做什么工做、时间节点是什么，可以借用Project工具，为开发任务分配资源、跟踪进度、管理预算和分析工作量。控制大型项目的第一个步骤是制定进度表，进度表由里程碑和日期组成。里程碑必须是具体的、特定的和可度量的事件，能进行清晰地定义。</p><p>　　过去的项目开发对时间的控制非常糟糕，大部分项目最终完成所用的时间都是自己初期预估的三倍，这到也成了自己的一条经验。客户、公司给出的时间和自己的预估相差很大，所以自己的早期预估只能是非常保守的预估，后面就是长期的和公司、客户拖延时间。还真应了那句编程名言：最初的90%的代码用去了最初90%的开发时间，余下的10%的代码用掉另外90%的开发时间。项目经理心里面应该有非常明确的人员安排计划、时间节点跟踪计划，并将其落实到文档中。开发进度应该严格依照进度表推进，并根据明确的时间节点（里程碑）进行定期的考核、演示。</p><p>　　在需求分析之后应该有初步的流程草图、模糊的项目模型和相对明确的需求确认书，而在项目设计之后，必须有客户确认的前端效果图、完整的数据库表结构、数据库文档及详细具体的项目开发文档。这个项目开发文档，可以是一份，也可以拆分成多份。里面有开发背景、需求分析、业务流程、技术难点、架构、程序编写方式、人员安排、时间规划等等的详细介绍。当这些文档出来之后，我们的设计也就已经明确下来。</p><h2 id="五-项目开发"><a href="#五-项目开发" class="headerlink" title="五 项目开发"></a>五 项目开发</h2><p>　　项目开发环节所触碰的都是些具体的技术细节。在过去的项目中，开发环节所用到的时间要远大于前面提到的六分之一的比例，是最费心的。也正因此，才觉得自己过去项目开发前的设计工作做的很不完善，因为在设计理想的情况下，软件开发工作只不过是一些重复性的体力劳动，根本无需再耗费心力。</p><p>　　理想情况终归是理想情况，真实的情况是，自己接手的很多项目从架构、程序到页面、样式、脚本，甚至是前端设计工作，都由一个人独自完成。一方面，公司未必有足够的人力安排到你所在的项目；另一方面，即便人手足够，也未必能将合适的人拧合在一起去组建成一个团队。这又涉及到公司部门管理的问题。而一个人又很难掌握开发一个完整项目所需的、各部分的诸多技术细节，擅长写后台程序的人未必擅长写样式，擅长写样式的人未必擅长写脚本，擅长样式和脚本的人却又未必擅长做UI设计，虽然你可能都会，却很难做到都擅长，这是人的局限性——我一直在试图突破的局限性。</p><p>　　于是，在这种更多的、非理想的情况下，在一个人有局限性的情况下，我在做需求分析设计时是不可能事无巨细的。以自己当前的水平，设计过程并不能渗透到所有的细节中。虚拟的工厂毕竟不是真实的工厂，哪怕自己对所有的技术都很精通，怕也很难在前期设计阶段虚拟出一个和最终真实工厂一样的模型。项目设计者之间设计水平的差距就体现在这个构建虚拟模型的过程中，谁的设计模型虚拟的更真实、更具体、更合理谁就更胜一筹。优秀的设计者虚拟出的设计模型肯定和最终开发出的真实项目相差不大才对，因为在合理情况下，项目的物理实现（Realization）都能依照它的设计实现（Implementation）有条不紊的推进。</p><p>　　因上所述，项目设计者更应当在平时扎扎实实的提高自己各方面的基本功，以尽可能的完善前期设计。而为了应付非理想情况下的前期设计，项目开发者要注意的问题也有很多，就过去的经验，<strong>项目开发过程中要关注的主要有下面几项：</strong></p><p>　　<strong>第一个要注意的问题是页面、样式、脚本、程序的编写细节。</strong>我们在完成设计后动手开发，第一件要做的事情是将UI设计师出的效果图转换成HTML页面，也就是美工常说的切页。那页面是什么格式的，HTML、ASPX、JSP还是PHP？美工和负责前端脚本的开发人员、负责后台程序的程序员之间应该先达成一种共识，其实在项目设计阶段，这里应该是先规划好的：页面、脚本、后台程序间通过什么样的方式交互？虽然前台脚本和后台程序完全是两码事，在细节上差异巨大，但编写脚本和编写程序要追求的目标是相似的——脚本和程序的架构设计都应该尽可能的低重复、高扩展、易用易调取、安全，甚至是样式和页面的设计也应该追求类似的目标，比如页面、样式、脚本、程序都要求低重复性。如何保证高内聚、低耦合定律？如何在程序中抓捕所有的异常、不让任何一个异常被暴露？等等这些问题，在设计架构时就应该考虑到。自己过去的笔记中有关于架构的问题列表，应该做些整理，力求不再让这些问题出现在开发环节。不敢对样式和脚本的技术细节枉谈，但具体到后台程序的编写，思路可以参考《重构，改善既有代码设计》这本书，里面有很多代码重构的技巧、实例值得学习借鉴。在开发环节，前端和后台程序的编写是可以并行的。有些环节必须单步顺序执行，比如只有效果图出来后才能出切页，但大部分环节是可并行的。在不同的开发阶段团队人员的工作量也是不一样的，熟悉之后，可以更轻松的对团队中的人力资源进行调配。</p><p>　　<strong>第二个要注意的问题是代码生成器等工具的使用。</strong>要创造软件生产流水线，主要依赖的工具就是代码生成器。学会使用CodeSmith之后，代码编写的效率有了很大的提高。CodeSmith就像是软件工程中的机器人，其存在的目的就是为了消灭重复工作、消除体力劳动，让人专心于创造工作。像数据库设计工具PowerDesigner、代码审查工具StyleCop、程序帮助文档生成工具SandCastle等等都是类似的目的，学会使用这些工具，可以让自己的工作事半功倍。不过“有机械者必有机事，有机事者必有机心”，想要熟练的应用这些工具也是要费时间和心思的，而且工具并非万能的。比如CodeSmith，过去一直试图用其生成尽可能多的代码，但却总有些部分需要手动去改，这样整个项目的编码就会分成三部分：一部分是纯手工编写的，比如工具类库；一部分是混合的，既有生成的也手动更改的；一部分是纯工具生成的，比如数据库访问层。常用的工具类到是可以统一做下整理到工具类库，也不麻烦，但需要手工改动的其它部分还是要耗人力的。希望可以将这部分需要手工改动代码降到最低，让绝大部分代码可以由工具自动生成、自动修改。尽管便捷工具的问题有很多，但整体来讲，还是有不少好工具值得人花些时间去学习使用。</p><p>　　<strong>第三个要注意的问题是开发进度跟踪。</strong>在项目设计阶段，应该有比较明确的进度表才对，即便没有很明确的文档、没有用Project，项目经理心里也应该对时间有数，在某个时间点某个功能必须完成、在某个时间点必须出来可演示的版本、在某个时间点必须可以上线试运行、在某个时间点所有的项目开发工作必须完成。还是那句话，抛开时间来讲工作毫无意义。为了跟踪项目开发进度，确保项目的每个阶段性目标可以按时完成，定期的团队会议是不可或缺的。通过会议间的沟通协调，找出时间延后或提前的原因，以部署下一阶段的开发任务。当每个阶段性目标都可以准时完成时，整个项目的开发定然也能按时完成。</p><p>　　<strong>第四个要注意的问题是人与人间的沟通、协作。</strong>中小型的项目，一个人可以勉强应付的，我决不会希望去安排两个人。一个人面临再多的问题也都是项目的问题，多一个人性质就完全变了，沟通协调、意见统一、互相游说争辩，耗费的无用的时间可是要倍增的。但是，你总不可能所有的项目都独自开发，更多的情况下，还是要跟人合作的——人或多或少。良好沟通协作的前提是团队中所有的成员必须在出现不同意见时保持心平气和，团队人员和客户之间互相角逐，团队人员之间互相角逐，团队人员和团队领导者之间互相角逐，团队领导者和公司各部门、和公司领导之间也在互相角逐，费心费口舌！为了保证沟通渠道的畅通，定期的会议是必须的，团队也应该定期向领导作汇报，并时刻和用户保持沟通，时刻了解用户的想法、纠正可能的错误。一直到现在，都不敢说用户的需求已经全部确定了下来！</p><p>　　<strong>第五个要注意的问题是开发过程中的沼泽地。</strong>在开发过程中（设计阶段也有）经常会碰到突然毫无头绪的情况，有早期的设计也不管用，就是不知道如何走下去了。还有可能突然发现，后期一些功能的实现把整个程序结构全给打乱了，虽然跌跌撞撞完成了要实现的功能，却觉得程序超脱了自己掌控。再有就是开发遇到致命问题，如陷入泥沼一样，项目到了进退不得的地步。灵感丧失的状况经常出现，对着屏幕大脑却一片空白，这时通常会躲到空空的楼道阁间中来会踱步，才会理出些思绪。还有，自己开发的每个项目几乎都有相应的笔记，不停的写不停的分析，这些笔记一方面用于计划、安排、总结自己当前的工作，一方面帮助自己清理思路找到工作灵感。还是比较偏向于在灵感缺失时到外面去走走换个思路的办法，再就是平时应该多读些技术类的书、多关注网上的实际案例、多参与高难度项目的开发，让自己拥有源源不断的源头活水，如此，思维将永不枯竭。遇到程序结构被打乱的情况也无需担心，只要不影响大局，后面可以专门抽出时间来对相应的代码进行重构、整修。开发过程中沼泽地的出现大都还是因为早期设计考虑的不完整，如果早期对架构设计的足够灵活，增删功能都应比较自如才是，项目是不太可能出现致命问题的。应该在设计之时考虑到相应的回改机制，如果在开发过程中出现了一些不可测的问题，数据库、架构、程序能否方便灵活的做出相应调整？</p><p>　　<strong>第六个要注意的问题是程序文档的整理。</strong>规模较大的、比较正规的项目，程序文档不可或缺。程序文档在中小型项目中的作用并不大，因为团队间的协作开发完全可以通过直接查看源程序及程序注释来降低互相对接时出现的麻烦。<strong>Java</strong>中有javadoc命令，用于生成自己API文档的，.NET平台下有工具SandCastle。用工具生成就很简单了，所以不论具体作用有多少，最好出一份程序文档，哪怕仅仅是为了做做表面工作、提供给项目验收者查看。这里着重要说的是接口文档，如果按自己设想的架构，前端和后台程序间通过ajax调用WebServcie接口进行交互，那这个接口文档是必须的。而且，打算在新架构中将这些交互接口做成通用的，不仅提供给自己的项目前端使用，还可以将其开放给外部平台，如此，接口文档更是不可或缺。最好有个<strong>测试</strong>用的接口平台，比如在XX医院时见到的那种，可以方便的在平台上对接口进行测试，这对外部接口调用者来说是非常方便的。只是不知道，他们用的什么技术做成的那个平台。</p><p>　　上面提到的几点有些在前面章节已经做过介绍，比如时间规划、进度控制、人员协作等，这些工作本应在开发之前就已经规划好。但是，正如上面所述，很多情况下，需求分析、设计并不能做到理想中的完整、详细、具体，所以开发阶段还是要关注很多细节。开发前的分析设计对项目实际的开发工作有着决定性的影响，应劳记这一点，务必在真正动手开发前做好充分的准备。设计是思，开发是行，务必要三思而后行。如果问题都到开发阶段才被暴露出来，有些就会非常麻烦了。</p><h2 id="六-项目测试"><a href="#六-项目测试" class="headerlink" title="六 项目测试"></a>六 项目测试</h2><p>　　从接触技术至今，从未系统学习整理过<strong>软件测试</strong>相关的理论知识，也从未读过一本和项目测试相关的书籍。我的技术经验、思路大都来自于实实在在的开发实践，而在自己所接触过的项目中，测试又都是非常简略的一环，没有理论中的那般重要。为什么说“理论中的那般重要”，是因为在所了解到的项目开发理论中，几乎所有人都在讲测试环节是最重要的一部分，也是最耗时、最需要耐心的。</p><p>　　为了整理这一章节的内容，从网络上搜索了一些软件测试相关的<strong>文章</strong>，却并未看出多少端倪，不过，软件测试工程里几个重要的概念已经弄明白。下面先把这几个重要概念的介绍摘录到这里，这部分大都采摘于这个网址：<strong>黑盒测试</strong>、<strong>白盒测试</strong>、<strong>单元测试</strong>、集成测试、<strong>系统测试</strong>、验收测试的区别与联系。后面，会再介绍一下自己在实际开发中遇到的一些测试相关问题，并整理下自己的所思、所悟。</p><p>　　软件测试从测试方式上分为黑盒测试和白盒测试，从测试范围上可分为单元测试、集成测试、系统测试、验收测试 。黑盒测试、白盒测试、单元测试是开发人员分在不同的开发阶段要做的事情；黑盒测试、集成测试、系统测试是测试人员在测试周期内级层做的工作；验收测试一般是在用户方做的工作。</p><p>　　<strong>黑盒测试：</strong>不考虑程序内部结构和逻辑结构，主要是用来测试系统的功能是否满足需求规格说明书。 一般会有一个输入值，一个输出值，和期望值做比较。黑盒测试也称<strong>功能测试</strong>，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p><p>　　<strong>白盒测试：</strong>主要应用在单元测试阶段，是对代码级的测试，针对程序内部逻辑构，测试手段有：语句覆盖、判定覆盖、条件覆盖、路径覆盖、条件组合覆盖。白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。这一方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择<strong>测试用例</strong>，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。</p><p>　　<strong>单元测试（Unit Testing）</strong>，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试</p><p>　　<strong>集成测试：</strong>是在软件系统集成过程中所进行的测试，其主要目的是检查软件单位之间的接口是否正确。它根据集成测试计划，一边将模块或其它软件单位组合成越来越大的系统，一边运行该系统，以分析所组成的系统是否正确，各个组成部分是否合拍。集成测试的策略主要有自顶向下和自底向上两种。也可以理解为在软件设计单元、功能模块组装、集成为系统时，对应用系统的各个部件（软件单元、功能模块接口、链接等）进行的联合测试，以决定它们能否在一起共同工作，部件可以是代码块、独立的应用、网络上的客户端或服务器端程序。</p><p>　　<strong>系统测试：</strong>系统测试是基于软件需求说明书的黑盒测试，是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确，并非一项简单的任务，被称为测试的“先知者问题”。因此，系统测试应该按照测试计划进行，其输入、输出和其他的动态运行行为应该与软件规约进行对比。软件系统测试的方法很多，主要有功能测试，<strong>性能测试</strong>，随机测试等。</p><p>　　在本章的开头提到，一方面理论说测试环节非常重要，另一方面在实践中却并未觉得它如理论所说的那般重要，这是矛盾的地方。并不是认为理论说的有错，只是自己目前用的是C#语言，开发的大都是WEB项目，主要是企业内部应用系统，项目规模都不大，可能和这些原因有关系（尤其是最后一个），所以测试环节在自己的项目中并不特别的重要。</p><p>　　企业内部应用系统一般都部署在专网、内网中，几乎不用考虑安全问题。小规模的项目，用户量很少，并发的问题、性能的问题也很少遇到瓶颈。如果项目不是被匆忙的开发上线，那从自己手里交出的项目有5%以下的可能出现问题。在被公司的其它人员（工程人员或其它开发者）测试之后，有4%以下的可能出现问题。这4%以下的问题要在上线试运行或正式运行之后才能被逐渐发现，再慢慢修正。</p><p>　　5%不是个小的数值，这还是保守的说法。这个数值受制于软件开发前期相关设计的合理性、软件工程所使用架构的稳定性、软件开发过程中的细心程度及在开发过程中使用的测试技巧，等。过去一直致力于在测试环节之外的设计、开发阶段将可能的BUG消灭掉，一直认为如果设计足够严密、开发足够谨慎，那出现BUG的机率自然会减少。从来不相信公司内部的测试流程，当然，也没有阻止过公司组织人员对软件进行测试。很清楚的知道，这帮家伙只能测试些表层问题，根本刺探不到根本。一直坚信，最好的测试人员就是产品的用户，所有的问题都会在实用中被暴露，但是，当软件的BUG暴露到了用户那里，这个软件产品还有没有资格被称为好的产品？</p><p>　　中小型的WEB项目，就自己的经验，<strong>在开发成型之后的测试、使用过程中主要会出现四类BUG：</strong></p><p>　　<strong>第一类是比较明显的错误。</strong>比如出现错别字，样式问题导致的页面显示混乱或对通用<strong>浏览器</strong>不兼容，表单字段合理性验证问题导致程序异常，页面之间的跳转出错，操作过程抛出程序异常（Exception），等。</p><p>　　<strong>第二类是不容易发现的错误。</strong>比如多用户同时操作导致的并发问题，程序编写规则有误导致的数据准确性问题，业务处理过程中出现明显过失问题，如给予某个角色不应有的权限，等。</p><p>　　<strong>第三类是在稍具规模的项目中常会出现的错误。</strong>比如由脚本、样式、程序导致的网络延迟，脚本、程序执行效率导致的响应速度过慢，数据量过大导致的数据库查询速度过慢，等等，大都是和性能相关的问题。</p><p>　　<strong>第四类是新版本发布导致的问题。</strong>比如配置文件被不小心覆盖、替换或内容被手动更改，WEB项目中的附属安装程序包在发布新版本时不小心被不同版本替换，根据用户要求对功能进行修改之后出现新的BUG，等。</p><p>　　上面并未提到可能的安全性问题，这方面不是我触及的项目所考虑的问题。在列举的这四类BUG中，第一类最为常见，这部分一旦发现，改起来相对容易，不会导致大的问题。第二类最为致命，不常见也不易被测试发现，如若在产品发布使用之后才被发现，很可能已经酿成祸端，数据的准确性或许已被破坏。第三类在小规模项目中不多见，即便出现较大数据的表，也大都在可控范围内。第四类是让我最头疼的，频繁的又相对简单的修改要求在项目发布之初是很常见的，而又很难针对每次的修改都进行全面测试，可每个简单字段的增删改都有可能导致出现新的BUG，所以常会有不可测问题出现。</p><p>　　再来看下发现项目BUG的人员，第一类是项目开发者，在开发过程中发现并修正。第二类是非专业测试人员，比如项目正式发布前对项目进行测试的工程人员、其它项目的开发者等。第三类是专业测试人员，掌握系统性测试理论和实用测试技巧的专业测试者。第四类是项目最终的使用者，在使用项目的过程中发现并反馈新的BUG。</p><p>　　寄希望于专业测试人员对中小型项目进行系统化测试是不现实的，一来大部分小规模的软件团队都没有专门负责测试的成员，二来即便有测试人员，也根本谈不上专业。软件测试的目的就是在其被正式使用前消除尽可能多的BUG，所以到第四类人（项目最终使用者）那里再发现问题，就已经晚了。对于第二类人（非专业测试人员）又信不过，他们只能发现些表层问题，却很难测出与业务相关的深层次BUG。在这种情况下，只能要求项目经理、开发人员在设计、开发阶段做更多的工作。白盒测试、单元测试、集成测试，都是很耗时的细节测试方式，如果在设计开发阶段做的足够好，可将这几种测试方式忽略掉，而专注于黑盒测试、系统测试、验收测试。只要机器可以正常运作，不要问机器内部是如何运作的——尽管这种处理方式或许不适合大型的软件项目。</p><p>　　在项目设计阶段尽可能的把数据库、架构、框架设计的足够灵活、稳定，在开发阶段尽可能的用代码生成器来完成程序的编写，这样可以从根源上杜绝很多BUG。对自己写的程序还是比较自信的，不是说不会出问题，而是说一旦出了问题能很清楚的知道问题出在哪里，可以在第一时间完成修复，这就是得益于自己对架构、程序的把握。开发阶段，每次完成一个独立的功能模块，都应对这个独立模块进行黑盒测试。相互之间有业务联系的模块，对其中某个单独模块进行改动后，都应对整个业务做完整的黑盒测试。开发者在开发阶段对项目的测试是频繁的、模块化的、间歇性的、迭代的。如果做到这些，项目从开发者手里交付后，再出现明显BUG的机率就会很小了。</p><p>　　项目从开发者手里交付后，应该部署到尽可能贴尽实际运行环境的服务器中，然后由公司组织人员进行测试。应该征集尽量多的人对项目进行深入测试，每个人把测试出的问题按要求整理成统一格式的测试文档，交付给项目负责人处理。项目负责人把这些问题归类后，逐个解决，并将处理后的结果反馈到测试文档中，之后开始进行第二轮测试。如果第二轮测试出的一些问题并非是由于第一轮测试之后对项目进行的修改导致，那说明这些问题是在第一轮测试时就该被发现却没有被发现的，这就是测试者的失误。在过去的测试中，经常遇到这样的情况，重复测试发现的问题并非新问题，而是因为测试不严谨导致的本来在最初时该发现却没有被发现的问题。觉得有必要让测试者明白这个道理，让每一次的测试尽可能的仔细。</p><p>　　对于测试出的问题，通常会有两类。一类是明显的错误，这个无可厚非，直接改正过来就是了。还有一类“似是而非”的，是测试者的主观意见，比如他觉得这个地方字体太小了、他觉得这个地方这样操作不合理等等。前面就说过，对项目的最终展现有决定权的只能有两个人，一个是客户，一个是项目经理。测试人员反馈的这种似是而非的问题项目经理可以留意，但最终是改还是不改，并不由测试人员来决定，这一点应该明确给所有人。</p><p>　　项目被公司组织人员测试之后，正式部署到客户要求的服务器中。正式部署之后应该先试运行一段时间，没有大的问题，才能被正式使用。试运行阶段及正式运行初期，客户很可能会反馈不少新问题，有些是明显的错误。不过，如果前期测试严密的话，这时更多反馈的应该是修改意见，比如增删改些字段，变换下操作方式，等等类似于公司测试人员的“似是而非”的问题。对于这些“似是而非”的修改要求，项目经理应根据实际情况和客户之间商讨决定。每次更改之后、发布新版本之前，应该把更改过的相关业务从头到尾再测一遍，这的确比较耗时，尤其是客户频繁更改的情况。为了减少频繁的更改发布，应该想办法让客户尽可能的一次提出所有的更改要求——当然这不容易，不要今天提一点，明天想到了再提一点，频繁的更改发布会另出现新问题的概率大大增加。</p><p>　　正式部署之后的修改再发布就是版本更新了，发布时应该先检验新版本中配置文件的变化，有没有增加、修改或删除的内容，如果没有则不发布配置文件，如果有则和当前运行版本中的配置文件进行校对、整合。如果当前版本有要下载的程序包，注意要发布项目的程序包的版本和当前运行项目的程序包的版本的异同。还有，上传的文件应该存放在独立于项目之外的虚拟目录中，即能防止发布时不小心被覆盖或修改，又方便后期的文件备份。发布项目时要注意的问题应该整理成文档，发布操作严格依照文档说明进行，可有效避免发布导致的不必要问题。</p><p>　　本章节讲得并不是具体的测试技巧，甚至有好多和测试无关的内容，但目的都是一个——在项目正式运行之前将可能的BUG数量降到最底。这并非正规的测试方法，只是自己的经验，如果有可能在大型项目中做开发工作，到是很有兴趣了解下正规的测试如何进行。</p><h2 id="七-运行维护"><a href="#七-运行维护" class="headerlink" title="七 运行维护"></a>七 运行维护</h2><p>　　运行维护本来是两部分，但因为要讲的内容不多，所以这里将二者合在一起。</p><p>　　项目经过公司内部的循环测试之后正式发布，通常情况下，客户会提供给专门的服务器供我们部署。有的是现成的服务器，已经安装好系统，有的则是空服务器，这时往往是工程实施人员负责系统的安装。工程实施人员有时也会安装好要用的数据库，不过也有时候由开发人员自己安装。操作系统、数据库安装之后的工作大都由开发者自己来做了，比如特定版本的.NETFramework的安装、Oracle数据库客户端和操作工具的安装、IIS和FTP的部署等等。</p><p>　　其实工程实施人员能做的工作很少，大部分运行维护相关的工作还是要由开发者自己亲自动手，自己开发的项目当然自己最清楚。发布项目到服务器时，很少碰到一次性顺利部署成功的情况，总会出现各种各样的小问题，有时是系统、数据库的问题，有时是IIS的问题。应该跟工程人员事先交待好，务必按要求安装合适版本的系统和数据库，且必须是纯净版的，这可以减少很多不必要的麻烦。遇到多个项目部署在同一服务器中的情况，注意可能产生冲突的部署、可能产生冲突的软件，比如曾经在部署FTP服务器时怎么配置也不成功，后来才发现是因为和同事部署的“FileZilla Server”冲突。数据库和项目在相同服务器中和在不同的服务器中，也可能会出现不同的问题，尤其像Oracle这种大型数据库，客户端版本不同、配置不同都会出现很多恼人的问题，应该注意。</p><p>　　出现问题时也不要心急，如果在自己开发用的机器上、在公司的测试服务器上都能成功运行，而在正式服务器上却出现问题，大都还是因为运行环境而致。有可能是数据库或IIS配置有问题、也有可能是操作系统中有关键性文件缺失，比如过去就遇到系统中缺失msvcr100.dll文件的情况，最后将文件打包到项目的BIN目录才算解决。遇到问题先要明确问题、明确问题出现的原因，之后再寻求解决问题的办法，不要盲目的胡乱配置测试。</p><p>　　一旦项目在正式服务器上正式部署，则通知客户方的负责人，开始试运行。试运行阶段是必须的，即便经过非常严谨的测试，也不能保证项目绝对不会再出现错误，试运行也是为了进一步保证正式运行的稳定。再者，试运行阶段不仅仅是为了发现可能的新BUG，更多的是为了解系统用户对当前系统的意见。其实很不喜欢客户在系统运行之后没完没了的提出修改要求，尤其是系统的功能、界面在设计之处早就已经详细确认好了的情况，如今刚做完却又要变更。不过，即便如此，还是应该听一下意见，特别是比较大、比较重要的项目，甲乙双方都有责任让这个项目变得更好。</p><p>　　在项目试运行之前，必须有一份系统帮助文档，以供工程实施人员及系统用户查看。文档可以由开发者自己编写，也可以由负责系统测试或实施的人员编写。用Word编写后保存成网页格式，挂载到系统比较明显的位置，并提供源Word格式的下载链接。还应该注意一下操作文档的更新，当系统功能有修改变化时，帮助文档也应做出相应的变更。</p><p>　　系统试运行之后，开始正式运行，随着正式运行时间的增长，系统会愈来愈趋于稳定。系统用户会逐渐的熟悉适应当前的系统，不适应的会反馈到开发者那里，由开发者对系统进行修改让系统反过来去适应用户，在这个过程中系统使用者和系统本身之间配合的也会越来越默契。一旦系统运行稳定下来，再出新问题的可能性就不大了，不过再修改的可能性还是有的，因为客户的需求无限的。比如现实的需求或者是他们突然想起来要新增些什么功能、要修改些什么功能，这些新增、修改的要求都属于对系统的扩展升级，这部分下个章节详细介绍。</p><p>　　项目正式运行并趋于稳定之后，再出现明显的错误就是很特殊的情况了，为了方便的查找出现这些错误的原因，系统应该有自己的日志记录功能。在架构、程序的设计阶段就应该考虑好日志功能，登录日志、操作日志、异常日志都要做记录，以备出现万一时查看。后期设计的架构中都有日志记录功能，对用户登入系统后的每个动作都进行了详细记录，可以很方便的查看系统使用者对数据的增、删、改操作。查询操作较为频繁，用户在登入系统后的每个动作都有可能触发对数据库的查询，所以对这部分的记录处理的不是很好。不是不好记录，而是不好对查询记录进行分类。比如之前的架构中，在伪业务逻辑层都会有增删改查四类方法，同时会有四类方法的重载方法，这些重载方法会多一个是否记录日志的参数。如果要记录日志，直接调用默认方法即可，如果程序不要记录日志，则调用重载方法并传入false（不记录日志）参数。通常情况下，增删改这类写操作都要记录日志的，不过有些查询操作却没有记录日志，比如当用户在登录系统时，也是调用的查询方法，但有登录日志功能专门对这个操作进行记录，那这个查询操作实际并无必要记录在操作日志中，操作日志记录的都是已经登录系统的用户执行的操作，每个操作都要记录执行这个操作的用户的ID。再比如，用户在新增卡片信息时，系统可能要先判断一下这个卡号是否已经存在于数据库中，并给出相应的提示，那这个系统业务自身执行的操作还要不要记录在操作日志中呢？过去没有对这些查询进行记录，但是不是可以完整记录，然后对操作记录进行分类，哪些是用户直接解触发的、哪些是间接触发的由系统业务执行？可不可以把操作来自于哪一个页面哪一个控件、执行的哪一个动作都进行分类记录，以方便后期的查阅呢？对于异常日志，是不是要单独记录到本地文件中呢？因为系统一旦运行稳定，操作异常很有可能是由于数据库失联而导致的，这时如果仅凭操作日志怕是查不到原因的。这些都是非常具体的技术细节，是在系统设计阶段应该考虑的问题。总之，为了后期的运行维护，日志功能不可或缺，且必须设计的足够严谨灵活易用，可以藉此清楚的了解系统运行情况。</p><p>　　最后一个要讲的问题是数据备份，主要是数据库备份和上传文件备份。项目后期的维护过程中，数据备份是最重要的一个问题。假如服务器瘫痪掉，甚至是硬盘出现了物理损坏，你的项目还能否完好恢复？SQLServer数据库有定时备份机制，但使用起来不是很好，设置好后总是莫名其妙的终止，自己也没有尝试过这种备份文件是否可以成功恢复。至今不熟悉Oracle数据库的自动备份机制，即便有像SQLServer数据库那样的自动备份功能，如果仅仅是在本地硬盘上备份，还是无法应对服务器硬件损坏的情况。一旦硬盘损坏，所有数据的恢复就都不好弄了。再就是和数据库对应的，比如用户上传的一些图片文件，这个之前说过，用户上传的文件必须存放在独立于项目文件之外的虚拟目录中，这种文件的备份又该如何处理？如何建立完善的备份机制？</p><p>　　理想的情况，一个系统应该至少两台服务器，两台服务器之间的数据相互同步，可利用类似于<strong>MySQL</strong>数据库主从复制的功能来实现这种同步。这样如果一台服务器出现问题，还有另一台，但小型项目中不大可能为一个系统配置两台服务器。在过去的技术生涯中并未遇到过服务器硬件出现损坏的情况，但还是觉得没遇到并不到代表没有这种可能，一旦出现这种情况，如果系统比较重要，结局就会是灾难性的。目前网络上流传的对Oracle数据库自动备份的方法，大都是利用批处理脚本完成。具体导出方法和自己平时用的一样，也是执行的exp命令，不过加上批处理后隔段时间执行一下这个导出命令。对于系统用户上传的文件，可以用一些定时压缩备份工具进行备份。利用这些方法，把数据库和上传文件备份到一个特定的文件夹中，然后再利用FlashFXP这类FTP上传工具，定时将备份文件上传到FTP服务器中。一般情况下，项目所在的服务器都可以访问外网，而公司也都会有多台外网服务器，可以在上面搭建一个FTP供上传备份。也可以利用SoftEther搭建VPN，将备份数据保存到自己电脑或公司内部的源代码服务器，这是自己目前能想出的唯一可行的完美备份方案。</p><p>　　备份部分还有一个要提醒的问题，就是在发布新版本系统前，应该先对当前运行的版本进行备份，也就是说先备份在发布。这样做的目的是，如果发布的新版本出现问题，可以及时恢复到过去的版本。对于数据库的增删改等手工操作，也应该先对数据库进行备份，以防万一。</p><p>　　还有一个和项目的运行维护关系不大的、备份相关的问题，想在这里提一下，就是源代码管理器的备份。目前使用的源代码管理器是TFS，应该了解下对这个TFS的备份方法。项目的历史修改记录都在源代码管理器中，如果这个存放源代码的服务器有个三长两短，也是很要命的。</p><h2 id="八-扩展升级"><a href="#八-扩展升级" class="headerlink" title="八 扩展升级"></a>八 扩展升级</h2><p>　　在自己看来，评价一个项目是否重要的核心因素只有一个，那就是项目被使用的频率。如果每天都有很多人在用它，它自然就很重要。项目在稳定运行之后，如果客户和公司有比较长的合作关系，且项目比较重要，那后期扩展升级的可能性就会非常大。自己负责开发的项目，简单的增改些功能到也算不上难题，真正另自己觉得麻烦的是另外一种情况，扩展升级别人开发的项目。</p><p>　　无论是别人开发的项目还是自己开发的项目，对项目的扩展升级都会分两种情况。第一种情况是，项目的核心业务没有多少变动，而只是做些简单修改或者是增加些附属业务。前段时间XX医院要求在现有会诊平台中加入转诊住院功能就属于这种情况，项目原有数据库结构不做大的变动，但会增加新的表结构来实现新增的附属业务。第二种情况是，项目的核心业务有了较大的改动，当前的数据库结构已经无法满足新业务要求，数据库必须重建。数据库一旦重建，程序以及前端就都要重写，也就是说整个项目都要重新开发，像之前的“YQZA系统”、“ZHJWBB系统”都属于这种情况。严格来讲，这种情况已经不算扩展升级了，这和重新开发一个新项目没多大区别。</p><p>　　针对第二种情况，无论之前的项目是谁开发的，到你这里都没有区别，都要重新开发。就把它当成一个全新的项目，按上面章节中所说的方法了解需求、分析、设计、开发、测试。因为是二次开发，也可以参考借鉴一下旧的项目。</p><p>　　针对第一种情况，如果是自己开发的项目，简单增加些功能并非难事，因为整个项目都是自己做的，自己对情况比较了解。可如果这个项目是别人做的呢？按理应该是谁的项目谁来负责扩展升级维护，那假如这个项目的负责人、开发者离职了呢？在中小型公司中，这种情况很常见。一个人负责一个项目，甚至是一个人负责多个项目，一旦这个人撂挑子不干了，他手下的项目就会很麻烦。管理者自然会将这样的项目交付给其他人，这个接手的人在维护修改一个完全不属于自己的项目，困难可想而知。接手的“远程医学平台项目”就是这样，前面几经人手，程序早已混乱不堪、错误百出，但迫于种种情况，数据库又不能重新设计，只能在原有的基础上进行修改。对于这个项目，考虑到现实情况和时间限制，没有对数据库、界面以及核心业务做大的调整，但把所有的程序、样式、脚本都进行了重写。就是说把房子重拆后又建了一遍，但没有改动地基，建完后的房子和之前的看起来一模一样，外面的人看不出来，其实里面用的材料已经完全不一样了。这是当时能想到的唯一比较可行的方法，现在想来其实也不甚好，公司的很多人，尤其是管理层，只看表层的界面都以为根本没做什么工作呢。</p><p>　　总结一下上面的介绍，把针对项目的扩展升级重新划分成四种类别：第一种是对自己开发的项目完全重写，第二种是对自己开发的项目进行部分修改，第三种是对别人开发的项目完全重写，第四种是对别人开发的项目进行部分修改。</p><p>　　到了项目扩展升级这一步，项目开发者能做的工作其实并不多，我们在这一步工作中的难易很大程度上依赖于项目早期设计、开发、用人的合理性等等一些因素。反推一下，为了项目后期扩展升级的方便，项目开发前期应该注意哪些问题。</p><p>　　<strong>第一个要注意的问题在项目具体的技术实现上。</strong>数据库设计、架构设计、程序设计务必要尽可能的稳定、灵活。灵活，什么是灵活？灵活就是开发者在后期可以很容易的对已经成型的项目进行修改扩展。为什么数据库表中一定要存外键、一定要存字典编码而不是相应的文本信息？为什么数据库表中大都有CREATETIME、UPDATETIME、CREATEUSER、UPDATEUSER四个字段？为什么要对架构做很多不必要的分层？为什么本来可以很容易写的程序要绕这么多弯来实现？这些很多看似不必要的工作都是为了项目的稳定及后期可能的修改。还有具体到用户、单位、字典等基本信息，角色权限等基本业务，都是一个项目基础又核心的功能，此部分的设计必须足够灵活，后期才可能方便的进行扩展升级，这也是我为什么要做通用权限管理系统的原因。</p><p>　　<strong>第二个要注意的问题在项目开发的用人上。</strong>虽然之前说在可能的情况下项目开发团队中人的质量应该越高越好、数量应该越少越好，但公司较为重要的、较为核心的项目不应该轻易的全都交付在某个人身上，一个人主负责没问题，但要让多个人参与其中，以防人员流失后项目不稳定。这个真正实施起来并不容易，中小型公司中的开发团队人手本来就紧张，在调动人员的过程中如果强制让部门中互相合不来的开发人员在一起共同开发项目，项目的质量很难保证。除非是部门的团队协作文化很好，任何的几个人之间都能良好配合工作。即便如此，管理者心中也应该有数，把重要项目全部交到一个不太可靠的人手里是非常危险的。</p><p>　　<strong>第三个要注意的问题是统一代码规范。</strong>如果部门中所有开发人员使用统一的架构、统一风格的代码，就无需担心接手不是自己负责项目的扩展升级工作了。文乃心声，文不一，说明心不一。如果文统一了，所有人同心协力做项目，沟通协调还能有什么困难，还有什么事做不成？可这个实施起来也是非常困难的，统一代码规范在某种程度上是要扼杀人的创造性的，没有哪个员工希望自己被束缚起来工作，尤其是被不合理的规范束缚。所以，如果要在开发团队中推行统一的代码规范，首先要制定出一套合理的规范，把大家叫到一起研究，听取每个人的意见，先在某个项目中试行，然后再全面推广。同时建立代码审查机制，用代码审查工具考核所有人的代码，逐步让这一制度深入人心。代码规范应该在统一和尽可能减少对人创造性的扼杀间找到一个平衡点，具体到代码规范的制定可以参考这篇文章：软件项目质量保证——编码规范。</p><p>　　<strong>第四个要注意的问题，由上两个问题延伸而来，有关团队的建设。</strong>把能力、品性参差不齐的人凝聚在一起不是件容易的事情，但从事实的角度来讲，一个人技术能力再强，能做的工作毕竟是有限的。况且，一个人也不可能精通所有技术的所有细节，必须要依赖于团队的力量。从个人来讲，不太喜欢和别人合作开发，尤其是在自己完全可以独立完成的情况下。是的，因为有人就会有意见不统一，有意见不统一就会有争执，有争执就要有磨合，磨合的过程是痛苦的。很多时候，不觉得经历这种痛苦是必要的。但是如果站在公司和管理者的角度，团队的磨合却是非常必要。一个人的性格不好塑造，但一个团队的性格却可以。部门内部一盘散沙，团队人员频繁变动，没有统一的开发套路，没有规章制度，没有默契，这样的团队怎么能做成事情？能不能成功在于两方面，第一是你选择的方向对不对，能不能选对要做的事情。在职场，具体到要做什么样的项目往往由公司的大方向决定，自己能左右的不多。第二方面是能不能把选对的事情做好，这一点是自己可以把握的，研发部门就是要有一个可以把任何项目都做能好的团队。为了训练出这样一支团队，部门管理者应该是懂技术的、懂管理的、强势的。为了让团队中的所有人使用统一的开发环境、统一的架构、统一的代码规范、统一的文档规范，管理者也应该独裁。只是现在管理者和员工并非君臣关系，游戏规则是由公司、公司的管理者来决定，但玩不玩却是由员工自己来决定的。强势的领导可能会让下属觉得不舒服，造成人员的流失。首先你的规则必须是合理的，别人才会同意跟你玩，结合实际情况制定合理的规则，推行时讲就技巧和方法。管理者必须是强势独裁的，但管理方法应该是民主的。再就是实战，成吉思汗的军队战无不胜不是因为他们武器先进，而是因为他们久经沙场。要不停的打仗，不断的接手新任务，在实战中锻炼队伍。再就是中小型公司的人员本来就不多，最好不要同时招收用不同编程语言的开发人员，要Java就全都招做Java的，要.NET就全都招做.NET的，这样也方便通力协作。用不同编程语言的开发人员，怎么好拧成一个团队？</p><p>　　上面四点都是在反推为了项目后期扩展升级的方便，项目开发前期应该注意哪些问题。在事情发生问题之后再想解决办法，已经输了，在发生问题之前就预料到可能要发生的问题并采取相应的预防措施才是真正高明的，所以说“上工治未病，不治已病”，与其亡羊之后再补牢，何不提早的未雨绸缪？项目到了扩展升级环节，工作的难易大都依赖于之前所做的工作，不过这里还是要讲一下这个环节要注意的几个问题。</p><p>　　<strong>第一个是先做决定。</strong>在接到扩展升级要求后，先根据实际情况来决定是对项目进行重写还是修改、是部分重写还是部分修改，决定的依据主要有：项目本身的重要性如何、项目是自己开发的还是别人开发的、扩展升级需求对核心业务的影响大不大、客户及公司允许的时间上限是多少、重写和修改的个人及公司的时间等成本各如何、重写和修改的对个人及公司的收益各如何、部门领导的意见如何，等等。对于别人开发的项目、核心业务变动需求较大的、改造时间充裕的情况，尽量直接重写；对于自己的项目、核心业务变动不大、改造时间较短、项目不是特别重要的，尽量只做简单修改。接手远程医学平台项目的修改工作时，我对所有程序做了重写，但没变动数据库和最终展现效果，依据就是：核心业务变动不大但程序是其它人开发已混乱不堪，没有专业美工不好做界面变动，公司允许的时间比较紧张。不过通常情况下，不会遇到这么复杂的情况，一般的扩展升级就是对自己负责的项目增加些功能。</p><p>　　<strong>第二个是对项目做简单修改时要注意的问题。</strong>扩展升级如何保证当前正运行版本不受干扰，如何不搞乱当前系统的主架构和核心业务？针对这一点，除了要依赖早期架构、程序的灵活外，自己在做修改时也应该注意，尽量不要删改原有的程序或数据库表、字段，如果在原有数据库表中增加字段、或在原有程序中增加新程序时，务必谨慎，并做好测试工作。尽可能的让自己新增的功能和原有的功能保持独立，如果不得以要修改原有的功能，注意被修改功能相关的其它模块可能受到的影响，最重要的还是做好测试工作。像远程医学平台这种项目，不同地方的核心业务相似但细节要求常有不同，比如申请会诊时有的要新增额外字段，如何处理定制部分、通用部分，另其互不影响，确保整个大平台的稳定统一？这些还是要依赖数据库、架构、程序的早期设计，项目设计者在技术能力之外还要对会诊业务有充分的了解，要有一定的行业经验。</p><p>　　<strong>第三个是重写项目要注意的问题。</strong>重写项目的决定必须要谨慎，考虑好彻底推翻重做的付出和收益如何，尤其是重写通用的、核心的项目，如果重写后的项目不能比重写前的优秀许多，重写意义是不大的的。重写应该借鉴原有系统的一些经验，可能的话，听听原有开发者及系统用户的建议，看看之前的工作有无可复用部分（估计有用的不会很多），或许会减少些自己的工作量。</p><p>　　关于扩展升级的介绍比较散乱，因为一直在倒推反思项目流程的前几个环节，设计、开发、用人，甚至是团队建设，觉得这些才是根本。也就是说，决定扩展升级工作的关键因素在扩展升级工作之外。</p><h2 id="九-梳理总结"><a href="#九-梳理总结" class="headerlink" title="九 梳理总结"></a>九 梳理总结</h2><p>　　了解需求、需求分析、项目设计属于项目完整流程的前期阶段，项目开发属于中期阶段，测试、运行属于项目的后期阶段，维护、扩展升级属于附属阶段。合理的情况下，在一个项目调研开发的完整流程中：三分之一的时间进行计划分析、六分之一的时间进行编码、四分之一的时间进行构件测试和早期系统测试、四分之一的时间进行完整的系统测试。但是，自己过去的经验，接触过的项目的重点环节并不在测试上面，而是分析设计阶段和开发阶段，后期阶段及附属阶段工作的难易很大程度上由前期的设计开发工作所决定。一方面是由于自己接手项目的性质相对另类，另一方面自己过去的项目开发流程有确实要些不甚合理。</p><p>　　回过头来看文档中描述的整套流程的各个环节，这些环节的工作最终大都要落实在文档上。尤其是需求分析、确认、设计阶段，如果没有文档，所有的工作都只能停留在虚无缥缈之中。整套流程中涉及到的文档资料主要有：业务流程图、需求确认书、界面效果图、数据库结构图、数据库文档、描述人员安排和进度跟踪的甘特图、开发文档、程序文档、接口文档、测试文档、软件操作说明书。其中数据库结构图、数据库文档、程序文档、接口文档都可以借助工具自动生成，项目接口和项目测试可借助相应的平台管理工具进行管理，相应的文档即可省略，总之，这几项都无需耗费多少人工。如果在项目开发文档中描述了大致的人员安排及时间规划，可以省略掉描述人员安排和进度跟踪的甘特图，如果比较大的项目也可以用Project绘制出相应的甘特图，这一项是非必须的。业务流程图、需求确认书、界面效果图、项目开发文档、软件操作说明文档，这几项是必须的，尤其是项目开发文档，不可或缺。业务流程图大都由Visio绘制，但这个工具的局限性很大，自己不太喜欢，如果能熟练使用PotoShop绘制流程图，可表现形式会更丰富些，项目经理应该学习使用。当然最好的绘制方式就是纸和笔，但不好表现成电子文档。界面效果图由美工完成，项目经理无需费心。网上有很多需求确认书及开发文档的模板，自己可以借鉴整理出一套自己的模板，每次复用即可。项目操作说明文档写起来比较容易，可交给工程实施人员编写。</p><p>　　除去工具生成部分、美工负责的效果图、工程实施人员负责的软件操作说明书，项目经理要写的文档很少，只有业务流程图、需求确认书和开发文档，这些大都有模板可套。无论是工具生成的部分还是人工编写的部分，一定要清楚的是：这些文档不是招标书，不是为了应付形式而做，而是有实实在在作用的，是这个项目、是自己、是整个团队后续工作的依据，文档的编写应该是正式的、规范的、认真的、实用的。当你熟悉这些文档的编写时，也就熟悉整套软件开发的流程了。还有，我认为敏捷开发方式不是说不写文档，而是要尽可能减少不必要的文档，并借用工具把花费在必要文档上的时间降到最低，以期用最少的时间和精力把脑海中的模型表现出来。比起文档的编写核定，敏捷开发更重视团队间面对面的协调沟通。</p><p>　　在最早接触实际项目的开发工作时，认为一个好项目的评判标准主要依据这几个方面：安全性、稳定性、兼容性、易用性、可扩展性和其能完成的具体功能，等。好项目中的好程序则在于程序的健壮性、执行效率、高内聚低耦合不重复、易修改升级扩展、及规范化编写，等。现在看来这些评判未必全面、未必合适，但这着实竖立了自己早期的、针对软件的价值观。已经清楚的知道如何做一个好的项目，却不知道如何在最短的时间内花费最少的精力完成这样一个好的项目，所以才会有这篇文档。</p><p>　　熟悉建站CMS的人都清楚，一旦网站的整体风格设计完毕，可借助CMS在非常短的时间内完成整个网站建设的具体工作。因为CMS的开发者摸清了网站建设的一些通用规律，所以才会设计这样一种工具。也希望如此，把整套软件开发的流程流水化处理，不仅要借助工具把具体开发工作花费的时间降到最低，还要把分析、设计、测试、运行、维护等环节花费的时间进行压缩。</p><p>　　本文档中关于软件开发的整套流程以及各环节的关键点，已经介绍的比较详细。表面上看这些环节比较复杂，但如果你熟悉下来，实际工作花费的时间非常少。后面就是依据文档中的介绍，将每一个环节的工作都熟练掌握、了然于胸，在实践中摸索出一套自己的流程。大致的思路应该是和文档中的描述一样，但更适合自己。一旦知道如何将项目开发工作流水化处理，无论是业务比较复杂的还是相对简单的，软件开发的时间将不会有大的差别。要想让架构稳定灵活功能强大，其设计必然相对复杂，但软件本身的功能和架构的复杂度对开发时间的影响并不大，真正影响开发时间的是开发团队的技术熟练程度。如果你比较熟悉开发套路，复杂的项目也可以很快的开发完成，反之亦然。就像影响汽车生产速度的并不是汽车本身的复杂度，而是汽车生产流水线的先进程度，本篇文档就是在告诉你如何制造一个先进的软件开发流水线。</p><p>　　本文档中的所有记述都来自于实践，之前也说过，自己所接手的大都是中小型团队的中小型项目，大都是B/S的企业内部应用系统，所以文档中的经验并不是对所有类型的软件开发都适用。其实B/S和C/S并不重要，仅仅是表现层不同。自己开发过的、接触过的、见过的企业内部应用系统中，也没有能称得上“大型”的项目，在我看来，绝大部分企业内部应用系统都只能属于中小型的范畴，而真正的大型项目应该是微博、淘宝网、<strong>腾讯</strong>网易门户网站这类的互联网软件。就自己过去的了解，大型互联网项目的开发是和中小型企业内部应用系统的开发有本质区别的——在需求调研、人员分工、架构设计、开发测试等等各个环节，自己也没有更大规模的项目开发经验了，所以不敢对此枉谈。不过，我相信，对于绝大部分企业内部应用系统，本文档中的经验都是适用的，本文档中所描绘的软件生产流水线也足以应付绝大部分企业内部应用系统。</p><p>　　再要讲的是团队建设。几乎在上面的各个章节中都谈到人的问题，越来越清楚的意识到，从领导层和公司的角度来看，在集体中仅仅是做好自己，远远不够。在中小型公司中，一个研发部就算是一个小的团队。不停的在问自己，如果让你负责从零组建一个公司的研发部，你会怎么做？反思自己工作之后待过的诸多团队，<strong>认为优秀的团队应该至少具备下面四个要素：</strong></p><p>　　<strong>第一是清晰的团队战略。</strong>研发部门的战略是和整个公司的战略密不可分的，首先是整个公司的战略目标明确，其次是公司交给研发部的任务战略明确。没有明确目标的团队是无法支撑下去的。</p><p>　　<strong>第二是优秀的团队领导人。</strong>团队领导人是团队建设的中坚力量，要求比较高，要懂技术、懂管理、平和有凝聚力、务实。只有优秀的领导人，才可能打造出优秀的开发团队。</p><p>　　<strong>第三是务实的团队氛围。</strong>氛围就是一种文化，只有务实，才能踏踏实实的做好事情。完善的制度、合理的规范、优秀的团队成员和团队领导人及公司的整体文化都在影响着团队的氛围，这是一种综合作用的结果。</p><p>　　<strong>第四是人才和技术的积累。</strong>优秀的成熟的团队应该具备优秀人才和行业核心技术的积累，优秀的人才是指在人品和技术上都过关、且在公司工作多年不会轻易流动的员工，他们是研发团队的核心力量，技术积累是指可复用项目、可复用架构、可复用代码、可复用文档、技术规范等的积累。人才和技术的积累是团队稳定运行的资本。</p><p>　　回过头来回答刚才的问题，如果让自己从零组建一个开发部。首先在招聘第一批团队成员时应该慎重，不仅是要技术过关，更要有责任心和团队协作能力，只是，面试时技术好考</p>]]></content>
      
      
      <categories>
          
          <category> 项目开发流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目开发流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>降低真机测试的成本</title>
      <link href="2020/12/14/ni-hui-yi-shi-me-fang-shi-jin-xing-dui-zhen-ji-de-cheng-ben-jiang-di/ni-hui-yi-shi-me-fang-shi-jin-xing-dui-zhen-ji-de-cheng-ben-jiang-di/"/>
      <url>2020/12/14/ni-hui-yi-shi-me-fang-shi-jin-xing-dui-zhen-ji-de-cheng-ben-jiang-di/ni-hui-yi-shi-me-fang-shi-jin-xing-dui-zhen-ji-de-cheng-ben-jiang-di/</url>
      
        <content type="html"><![CDATA[<p>1.租赁平台上租用<br>2.找同事借用<br>3.二手平台上购买二手的<br>4.通过七天无理由退货，在七天内完成工作任务<br>5.手机用过之后通过内部价对公司内部成员进行销售<br>6.云测平台进行测试</p><h2 id="云测平台："><a href="#云测平台：" class="headerlink" title="云测平台："></a>云测平台：</h2><h2 id="1-Testin："><a href="#1-Testin：" class="headerlink" title="1.Testin："></a>1.Testin：</h2><p>​    Testin是国内较早涉足云测试领域的公司之一。Testin在云端部署了300多款1000多部测试终端，终端种类及数量都比较全面。支持Android与iOS系统。但目前仅少部分服务为免费，绝大多数服务为收费项目，故而使用成本较高，具体收费情况请查看官网的介绍。</p><h3 id="2-腾讯优测："><a href="#2-腾讯优测：" class="headerlink" title="2.腾讯优测："></a>2.腾讯优测：</h3><p>​    腾讯优测是腾讯旗下的云测试服务平台，拥有超过1000款测试终端，机型数量庞大。但仅支持Android，暂不支持iOS系统。提供兼容性测试服务，不提供性能测试、功能测试及稳定性测试服务。另外，腾讯优测还提供“云手机”服务，开发者可以远程控制测试终端，实时查看App安装、运行效果。优测目前的功能为收费（新注册的用户可获得官方赠送的礼包），每天限制提交2次测试。</p><h3 id="3-贯众云测试："><a href="#3-贯众云测试：" class="headerlink" title="3.贯众云测试："></a>3.贯众云测试：</h3><p>​    贯众云测试是中国移动旗下的云测试服务平台，目前拥有超过100款市面主流终端，支持Android及iOS系统。提供兼容性测试、功能测试、性能测试，稳定性测试（12小时）及网络场景测试服务（2G&amp;3G&amp;4G）。支持Appium脚本。缺点是终端数量较少，优点是功能较为全面，且基本功能都是免费，使用成本还是蛮低的。</p><h3 id="4-百度MTC："><a href="#4-百度MTC：" class="headerlink" title="4.百度MTC："></a>4.百度MTC：</h3><p>​    百度MTC是百度开放平台旗下的移动云测试中心。提供超过500款热门机型，目前只支持Android系统，暂不支持iOS系统。提供的测试服务种类有兼容性测试、性能测试、功能测试。并且提供了脚本录制工具，类似Testin。但脚本录制工具更新速度较慢。百度MTC的服务目前为收费服务，具体收费情况请查看官网的介绍。</p><h3 id="5-阿里MQC："><a href="#5-阿里MQC：" class="headerlink" title="5.阿里MQC："></a>5.阿里MQC：</h3><p>​    阿里MQC是阿里巴巴旗下的移动测试平台。提供上百款测试终端，支持Android及iOS系统。提供兼容性测试、功能测试、性能测试以及稳定性测试（1小时）。测试脚本需使用Robotium或Appium测试框架编写，难度较高。MQC也提供了远程的真机调试，功能和腾讯优测类似，看来腾讯和阿里还真是一对儿冤家啊。</p><p>花了点时间把他们的情况做了个对比，请看下面的表格：</p><img src="/2020/12/14/ni-hui-yi-shi-me-fang-shi-jin-xing-dui-zhen-ji-de-cheng-ben-jiang-di/ni-hui-yi-shi-me-fang-shi-jin-xing-dui-zhen-ji-de-cheng-ben-jiang-di/%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 降低真机测试的成本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降低真机测试的成本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公交地铁出行测试点</title>
      <link href="2020/12/14/gong-jiao-di-tie-ce-shi-dian/"/>
      <url>2020/12/14/gong-jiao-di-tie-ce-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-测试项：分类、充值、使用、乘车、余额、异常、注销"><a href="#1-测试项：分类、充值、使用、乘车、余额、异常、注销" class="headerlink" title="1.测试项：分类、充值、使用、乘车、余额、异常、注销"></a>1.测试项：分类、充值、使用、乘车、余额、异常、注销</h2><h3 id="1-分类："><a href="#1-分类：" class="headerlink" title="1.分类："></a>1.分类：</h3><p>​    按办理类型分为：电子公交卡和普通公交卡</p><p>​    按使用人群可分为：老年卡、学生卡、优惠卡</p><p>​    按用途可分为：纪念卡、定制卡、普通卡‍</p><h3 id="2-充值："><a href="#2-充值：" class="headerlink" title="2.充值："></a>2.充值：</h3><p>​    充值方式：充值机、人工充值、手机充值</p><p>​    充值金额：一次性最多充值金额、一次性最少充值金额、充值后余额是否显示正确</p><h3 id="3-使用："><a href="#3-使用：" class="headerlink" title="3.使用："></a>3.使用：</h3><p>​    城市使用范围：卡在所属城市是否可用、卡在非所属城市之外不可用</p><p>​    适用交通工具：公交车/地铁在卡办理后即可使用、可租借自行车需交付押金后才可使用、其他交通工具（火车、高铁）不可用</p><p>​    扣费规则：公交车按里程扣费、自行车按使用时间扣费</p><p>​    公交卡扣费：老年卡免费、学生卡享受优惠、普通卡无优惠；</p><p>​    地铁卡扣费：老年卡非高峰时段免费，学生卡享受优惠，普通卡无优惠</p><p>​    自行车卡扣费：一小时内免费，超出一小时每小时扣1元</p><h3 id="4-乘车："><a href="#4-乘车：" class="headerlink" title="4.乘车："></a>4.乘车：</h3><p>​    刷卡时是否有语音提示</p><p>​    扣费方式：公交卡在刷卡时扣费、地铁进入闸机时不扣费，出闸时正常感应扣费、自行车在刷卡租车时不扣款，还车时正常扣款</p><p>​    同一交通工具单人单次可刷卡次数：公交车在余额充足情况下不限次数、地铁/自行车只能刷一次</p><h3 id="5-余额："><a href="#5-余额：" class="headerlink" title="5.余额："></a>5.余额：</h3><p>​    不足5元时语音提醒余额不足</p><p>​    不足扣款金额时刷卡失败</p><h3 id="6-异常："><a href="#6-异常：" class="headerlink" title="6.异常："></a>6.异常：</h3><p>​    卡芯片损坏不可使用、卡芯片完好时可使用</p><p>​    卡消磁时无法感应</p><p>​    卡内余额不足，不可使用</p><p>​    卡已被注销，不可使用</p><p>​    公交刷卡时由于机器故障，是否正常处理</p><p>​    电子公交卡在手机网络不稳定、服务器异常、断网、断电时是否正常处理</p><h3 id="7-注销："><a href="#7-注销：" class="headerlink" title="7.注销："></a>7.注销：</h3><p>​    实名卡可注销、非实名卡不可注销、注销后不可使用</p><h2 id="2-测试角度"><a href="#2-测试角度" class="headerlink" title="2.测试角度"></a>2.测试角度</h2><h3 id="1-性能："><a href="#1-性能：" class="headerlink" title="1.性能："></a>1.性能：</h3><p>​        刷卡有效次数是否符合用户需求</p><p>​        卡正常保存是否不易消磁</p><p>​        卡灵敏度是否足够高</p><p>​        芯片是否不易受损</p><p>​        卡的耐热、热耐性、耐磨性是否足够好</p><p>​        卡的耐弯曲程度如何</p><p>​        卡的使用寿命是否符合需求</p><h3 id="2-兼容性："><a href="#2-兼容性：" class="headerlink" title="2.兼容性："></a>2.兼容性：</h3><p>​        在所属城市的不同公交车和地铁均可使用</p><p>​        在所属城市不同站点均可使用</p><p>​        在所属城市内的新旧公交车均可使用</p><h3 id="3-安全性："><a href="#3-安全性：" class="headerlink" title="3.安全性："></a>3.安全性：</h3><p>​        卡的材质无毒无害</p><p>​        卡芯片低辐射</p><p>​        卡棱角平滑不伤手</p><p>​        实名可易于挂失，找回</p><p>​        卡在高温和低温下保证正常，无毒无害</p>]]></content>
      
      
      <categories>
          
          <category> 测试点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http请求方法</title>
      <link href="2020/12/14/http-de-qing-qiu-fang-shi/http-de-qing-qiu-fang-shi/"/>
      <url>2020/12/14/http-de-qing-qiu-fang-shi/http-de-qing-qiu-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一-HTTP请求的方法："><a href="#一-HTTP请求的方法：" class="headerlink" title="一.HTTP请求的方法："></a>一.HTTP请求的方法：</h2><p>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式</p><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法</p><img src="/2020/12/14/http-de-qing-qiu-fang-shi/http-de-qing-qiu-fang-shi/Http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.png" class=""><h3 id="1、OPTIONS"><a href="#1、OPTIONS" class="headerlink" title="1、OPTIONS"></a>1、OPTIONS</h3><p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p><h3 id="2、HEAD"><a href="#2、HEAD" class="headerlink" title="2、HEAD"></a>2、HEAD</h3><p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p><h3 id="3、GET"><a href="#3、GET" class="headerlink" title="3、GET"></a>3、GET</h3><p>向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url</p><h3 id="4、POST"><a href="#4、POST" class="headerlink" title="4、POST"></a>4、POST</h3><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form</p><h3 id="5、PUT"><a href="#5、PUT" class="headerlink" title="5、PUT"></a>5、PUT</h3><p>向指定资源位置上传其最新内容</p><h3 id="6、DELETE"><a href="#6、DELETE" class="headerlink" title="6、DELETE"></a>6、DELETE</h3><p>请求服务器删除Request-URL所标识的资源</p><h3 id="7、TRACE"><a href="#7、TRACE" class="headerlink" title="7、TRACE"></a>7、TRACE</h3><p>回显服务器收到的请求，主要用于测试或诊断</p><h3 id="8、CONNECT"><a href="#8、CONNECT" class="headerlink" title="8、CONNECT"></a>8、CONNECT</h3><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p>注意：</p><p>1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。</p><p>2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求响应步骤</title>
      <link href="2020/12/14/http-qing-qiu-xiang-ying-de-bu-zou/http-qing-qiu-xiang-ying-de-bu-zou/"/>
      <url>2020/12/14/http-qing-qiu-xiang-ying-de-bu-zou/http-qing-qiu-xiang-ying-de-bu-zou/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP请求消息Request"><a href="#HTTP请求消息Request" class="headerlink" title="HTTP请求消息Request"></a>HTTP请求消息Request</h1><h2 id="客户端发送一个HTTP请求到服务器的请求消息包括以下格式"><a href="#客户端发送一个HTTP请求到服务器的请求消息包括以下格式" class="headerlink" title="客户端发送一个HTTP请求到服务器的请求消息包括以下格式"></a>客户端发送一个HTTP请求到服务器的请求消息包括以下格式</h2><h5 id="请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。"><a href="#请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。" class="headerlink" title="请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。"></a>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</h5><img src="/2020/12/14/http-qing-qiu-xiang-ying-de-bu-zou/http-qing-qiu-xiang-ying-de-bu-zou/http%E8%AF%B7%E6%B1%82.png" class=""><h5 id="请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本"><a href="#请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本" class="headerlink" title="请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本"></a>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本</h5><h5 id="Get请求例子，使用Charles抓取的request："><a href="#Get请求例子，使用Charles抓取的request：" class="headerlink" title="Get请求例子，使用Charles抓取的request："></a>Get请求例子，使用Charles抓取的request：</h5><pre><code>GET /562f25980001b1b106000338.jpg HTTP/1.1Host    img.mukewang.comUser-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept    image/webp,image/*,*/*;q=0.8Referer    http://www.imooc.com/Accept-Encoding    gzip, deflate, sdchAccept-Language    zh-CN,zh;q=0.8</code></pre><h5 id="第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本"><a href="#第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本" class="headerlink" title="第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本."></a>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</h5><p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p><h5 id="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息" class="headerlink" title="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"></a>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</h5><p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p><h5 id="第三部分：空行，请求头部后面的空行是必须的"><a href="#第三部分：空行，请求头部后面的空行是必须的" class="headerlink" title="第三部分：空行，请求头部后面的空行是必须的"></a>第三部分：空行，请求头部后面的空行是必须的</h5><p>即使第四部分的请求数据为空，也必须有空行。</p><h5 id="第四部分：请求数据也叫主体，可以添加任意的其他数据。"><a href="#第四部分：请求数据也叫主体，可以添加任意的其他数据。" class="headerlink" title="第四部分：请求数据也叫主体，可以添加任意的其他数据。"></a>第四部分：请求数据也叫主体，可以添加任意的其他数据。</h5><p>这个例子的请求数据为空。</p><h5 id="POST请求例子，使用Charles抓取的request："><a href="#POST请求例子，使用Charles抓取的request：" class="headerlink" title="POST请求例子，使用Charles抓取的request："></a>POST请求例子，使用Charles抓取的request：</h5><pre><code>POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley</code></pre><p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p><h1 id="HTTP请求消息Response"><a href="#HTTP请求消息Response" class="headerlink" title="HTTP请求消息Response"></a>HTTP请求消息Response</h1><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p><h5 id="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文"><a href="#HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文" class="headerlink" title="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文"></a>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</h5><img src="/2020/12/14/http-qing-qiu-xiang-ying-de-bu-zou/http-qing-qiu-xiang-ying-de-bu-zou/http%E5%93%8D%E5%BA%94.png" class=""><p><strong>例子</strong></p><pre><code>HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt;      &lt;head&gt;&lt;/head&gt;      &lt;body&gt;            &lt;!--body goes here--&gt;      &lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。"><a href="#第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。" class="headerlink" title="第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。"></a>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</h5><p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p><h5 id="第二部分：消息报头，用来说明客户端要使用的一些附加信息"><a href="#第二部分：消息报头，用来说明客户端要使用的一些附加信息" class="headerlink" title="第二部分：消息报头，用来说明客户端要使用的一些附加信息"></a>第二部分：消息报头，用来说明客户端要使用的一些附加信息</h5><p>第二行和第三行为消息报头，<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p><h5 id="第三部分：空行，消息报头后面的空行是必须的"><a href="#第三部分：空行，消息报头后面的空行是必须的" class="headerlink" title="第三部分：空行，消息报头后面的空行是必须的"></a>第三部分：空行，消息报头后面的空行是必须的</h5><h5 id="第四部分：响应正文，服务器返回给客户端的文本信息。"><a href="#第四部分：响应正文，服务器返回给客户端的文本信息。" class="headerlink" title="第四部分：响应正文，服务器返回给客户端的文本信息。"></a>第四部分：响应正文，服务器返回给客户端的文本信息。</h5><p>空行后面的html部分为响应正文。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http和https 区别</title>
      <link href="2020/12/14/http-he-https-de-qu-bie/"/>
      <url>2020/12/14/http-he-https-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a>一、HTTP和HTTPS的基本概念</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="二、HTTP与HTTPS的区别"><a href="#二、HTTP与HTTPS的区别" class="headerlink" title="二、HTTP与HTTPS的区别"></a>二<strong>、</strong>HTTP与HTTPS的区别</h2><p> 　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br> 　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br> 　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br> 　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="三、HTTP与HTTPS的工作原理"><a href="#三、HTTP与HTTPS的工作原理" class="headerlink" title="三、HTTP与HTTPS的工作原理"></a>三<strong>、</strong>HTTP与HTTPS的工作原理</h2><p>HTTP的工作原理：一次HTTP操作称为一个事物，其工作过程可分为四步</p><p>1、Client与Server建立连接，单击某个超链接，HTTP的工作开始。</p><p>2、连接建立后，Client发送一个请求给Server，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符，Client信息和可能的内容。</p><p>3、Server接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括Server信息、实体信息和可能的内容。</p><p>4、Client接收Server返回的信息通过浏览器显示在用户的显示屏上，然后Client和Server断开连接。</p><p>HTTPS的工作原理：</p><p>1、Client使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>2、Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>3、客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>4、客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>5、Web服务器利用自己的私钥解密出会话密钥。</p><p>6、Web服务器利用会话密钥加密与客户端之间的通信。</p><h2 id="四、HTTPS的优缺点"><a href="#四、HTTPS的优缺点" class="headerlink" title="四、HTTPS的优缺点"></a>四<strong>、</strong>HTTPS的优缺点</h2><p>优点：</p><p>1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>缺点：</p><p>1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>2、HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>3、SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>5、HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h2 id="五、如何将网站从HTTP切换到HTTPS"><a href="#五、如何将网站从HTTP切换到HTTPS" class="headerlink" title="五、如何将网站从HTTP切换到HTTPS"></a>五<strong>、</strong>如何将网站从HTTP切换到HTTPS</h2><p>如果需要将网站从http切换到https到底该如何实现呢？</p><p>这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="https://links.jianshu.com/go?to=http://www.baidu.com">http://www.baidu.com</a>改为<a href="https://links.jianshu.com/go?to=https://www.baidu.com">https://www.baidu.com</a></p><p>这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="https://links.jianshu.com/go?to=http://www.baidu.com">http://www.baidu.com</a>改为<a href="https://links.jianshu.com/go?to=//www.baidu.com">//www.baidu.com</a>。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+github+绑定域名搭建属于自己的博客网站</title>
      <link href="2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/"/>
      <url>2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="一，下载-node-js"><a href="#一，下载-node-js" class="headerlink" title="一，下载 node.js"></a>一，下载 node.js</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo 基于Node.js </p><p>Node.js 下载地址: <a href="https://nodejs.org/en/download/">Download | Node.js</a> 下载安装包，注意安装Node.js 会包含环境变量，及npm的安装，安装后，检测Node.js 是否安装成功，在命令行中输入 node -v:</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/node1.png" class=""><p>检测npm 是否安装成功，在命令行中输入 npm -v：</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/node2.png" class=""><h2 id="二，下载-Git"><a href="#二，下载-Git" class="headerlink" title="二，下载 Git"></a>二，下载 Git</h2><p>什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a> </p><p>下载地址： <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 现在的机子基本都是64位的，选择64位的安装包，下载后安装，</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/git1.png" class=""><p>在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/git2.png" class=""><p>或者在菜单里搜索Git Bash，设置user.name和user.email配置信息：</p><pre class=" language-python"><code class="language-python">git config <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">global</span> user<span class="token punctuation">.</span>name <span class="token string">"你的GitHub用户名"</span>git config <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">global</span> user<span class="token punctuation">.</span>email <span class="token string">"你的GitHub注册邮箱"</span></code></pre><p>生成ssh密钥文件：</p><pre class=" language-python"><code class="language-python">ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"你的GitHub注册邮箱"</span></code></pre><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/git3.png" class=""><h2 id="三，GitHub-创建个人仓库"><a href="#三，GitHub-创建个人仓库" class="headerlink" title="三，GitHub 创建个人仓库"></a>三，GitHub 创建个人仓库</h2><p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：<a href="https://link.zhihu.com/?target=https://github.com/">Build software better, together</a> 点击GitHub中的New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a> 这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/github1.png" class=""><p>创建仓库时一定要注意，下面图片黑色框中的东西，一定要选中，不然后面绑定域名没办法绑定。</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/github4.png" class=""><p>打开<a href="https://github.com/settings/keys">SSH and GPG keys (github.com)</a> 页面，新建new SSH Key</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/github2.png" class=""><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:git@github.com">git@github.com</a> ：</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/github3.png" class=""><p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h2 id="四，安装Hexo"><a href="#四，安装Hexo" class="headerlink" title="四，安装Hexo"></a>四，安装Hexo</h2><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中，右击鼠标GIT Bash Here</p><p>注意下面的命令都是作用在刚刚创建的Blog文件夹中:</p><p>使用npm命令安装Hexo 输入：npm install -g hexo-cli</p><p>安装完成后，初始化博客，输入： hexo init</p><p>为了检测我们网站雏形，分别按顺序输入一下三条命令：</p><pre class=" language-python"><code class="language-python">hexo n <span class="token string">"我的第一篇博客"</span>hexo ghexo s</code></pre><p>这些命令在后面介绍，完成后，打开浏览器输入地址：</p><p>localhost:4000</p><p>可以看到我们写的第一篇博客,</p><h3 id="常用的Hexo-命令"><a href="#常用的Hexo-命令" class="headerlink" title="常用的Hexo 命令"></a>常用的Hexo 命令</h3><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客</p><p>命令简写<br>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署</p><p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p><p>刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。  </p><h3 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h3><p>推送网站也就是发布网站，可以被更多人访问，</p><p>在刚才创建的blog目录里,有个_config.yml 文件夹，称之为<strong>站点配置文件</strong></p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/hexo1.png" class=""><p>进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为<strong>主题配置文件</strong>，如下图</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/hexo2.png" class=""><p>下一步将我们的Hexo与GitHub关联起来，打开<strong>站点的配置文件</strong>_config.yml，翻到最后修改为：</p><pre class=" language-python"><code class="language-python">deploy<span class="token punctuation">:</span>type<span class="token punctuation">:</span> gitrepo<span class="token punctuation">:</span> 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 <span class="token punctuation">.</span>gitbranch<span class="token punctuation">:</span> master参考如下：</code></pre><p>然后保存。</p><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p><pre class=" language-basemake"><code class="language-basemake">npm install hexo-deployer-git --save</code></pre><p>这时，我们分别输入三条命令：</p><pre class=" language-bash"><code class="language-bash">hexo clean hexo g hexo d</code></pre><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 xxx.github.io （xxx是你的github用户名）</p><p>比如我的就是: au-star.github.io</p><p>你就会发现你的博客已经上线了，可以在网络上被访问了</p><h2 id="五，绑定域名"><a href="#五，绑定域名" class="headerlink" title="五，绑定域名"></a>五，绑定域名</h2><p>虽然在互联网上可以访问我们的网站了，但是网址是GitHub提供的：xxx.github.io，而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名了。</p><p>我是在阿里云买的域名，也就演示一下用阿里云绑定域名吧。</p><p>登录阿里云之后，进入管理控制台的域名列表，</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D1.png" class=""><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D2.png" class=""><p>点击解析，包括两条解析记录，你可以 win+R 输入cmd 进入命令提示符ping 你的xxx.github.io 的 ip 地址，填入</p><p>新手可以点击新手引导。</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D3.png" class=""><p>然后进入你之前创建的github库中点击setting 往下滑会找到，如下图：</p><img src="/2020/12/14/hexo-github-bang-ding-yu-ming-da-jian-zi-ji-de-bo-ke-wang-zhan/hexo-github-bang-ding-yu-ming-da-jian-shu-yu-zi-ji-de-bo-ke-wang-zhan/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D4.png" class=""><p>Custom domain下输入你购买的域名，点击save保存.</p><p>没有找到这个模块的请上翻仔细看创建github库.</p><p>最后进入你的本地博客文件夹blog中，进入source目录下,创建一个记事本文件，输入你的域名，然后保存，命名为CNAME,不要带后缀名,保存为<strong>所有文件</strong>.</p><p>完成之后，进入blog目录，右击鼠标Git Bash Here,依次输入：</p><pre class=" language-bash"><code class="language-bash">hexo cleanhexo ghexo d</code></pre><p>然后打开浏览器，在地址栏输入你的域名就会直接进入你搭建的网站了。</p><p>更换主题目前我还没改完，以后会发出来关于改主题的博客.</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客网站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie和session 区别</title>
      <link href="2020/12/14/cookie-he-session-de-qu-bie/"/>
      <url>2020/12/14/cookie-he-session-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>1.cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。</p><p>2.session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。<br>注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。</p><p>3.cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。</p><p>4.cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。<br>简单的说，当你登录一个网站的时候，</p><p>如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造，但是如果你能够获取某个登录用户的 sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性.</p><p>如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的  cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy    cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器</p><p>5.两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。</p><p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p>]]></content>
      
      
      <categories>
          
          <category> cookie和session </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie和session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>charles抓取web端https</title>
      <link href="2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/"/>
      <url>2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/</url>
      
        <content type="html"><![CDATA[<p>charles抓取web端、模拟器https</p><h2 id="1-charles抓取web端https"><a href="#1-charles抓取web端https" class="headerlink" title="1.charles抓取web端https"></a>1.charles抓取web端https</h2><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/1.png" class=""><p>下载并将证书添加为受信任的根证书并进行安装</p><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/2.png" class=""><p>给ssl代理设置中进行添加https协议</p><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/3.png" class=""><h2 id="2-抓取移动端的htpps"><a href="#2-抓取移动端的htpps" class="headerlink" title="2.抓取移动端的htpps"></a>2.抓取移动端的htpps</h2><p>1.保证pc端和移动端在同一网络下<br>2.pc进行安装证书</p><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/4.png" class=""><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/5.png" class=""><p>3.去移动端进行设置代理服务</p><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/6.png" class=""><p>4.打开移动端默认的浏览器输入 chls.pro/ssl 网址 会自动下载并安装证书</p><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/7.png" class=""><p>5.Pc端会弹出一个允许框</p><h2 id="3-charles的弱网测试"><a href="#3-charles的弱网测试" class="headerlink" title="3.charles的弱网测试"></a>3.charles的弱网测试</h2><p>Charles的弱网测试其实是修改了 请求或者是响应的网速以及时间<br>2g/3g/4g wifi</p><p>1.charles中proxy–throttle settings 可以指定网址进行弱网以及不指定网址进行弱网测试</p><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/8.png" class=""><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/9.png" class=""><h2 id="4-charles的黑名单模拟错误状态码"><a href="#4-charles的黑名单模拟错误状态码" class="headerlink" title="4.charles的黑名单模拟错误状态码"></a>4.charles的黑名单模拟错误状态码</h2><img src="/2020/12/14/charles-zhua-qu-web-duan-https/charles-zhua-qu-web-duan-https/10.png" class=""><h2 id="5-charles的请求断点替换："><a href="#5-charles的请求断点替换：" class="headerlink" title="5.charles的请求断点替换："></a>5.charles的请求断点替换：</h2><p>动态断点替换:<br>本地断点替换：</p><h2 id="6-charles的响应断点替换："><a href="#6-charles的响应断点替换：" class="headerlink" title="6.charles的响应断点替换："></a>6.charles的响应断点替换：</h2>]]></content>
      
      
      <categories>
          
          <category> charles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> charles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GET与POST区别</title>
      <link href="2020/12/04/get-he-post-de-qu-bie/get-he-post-de-qu-bie/"/>
      <url>2020/12/04/get-he-post-de-qu-bie/get-he-post-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="GET与POST："><a href="#GET与POST：" class="headerlink" title="GET与POST："></a>GET与POST：</h1><p>　“get”方法提交的数据会直接填充在请求报文的URL上，如“ <a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1</a> ”   “？”问号划分域名和get提交的参数，A=B中的A是参数名，B是参数值，多个参数之间用&amp;进行分割，如果参数值是中文，则会转换成诸如%ab%12加密16进制码。一般来说，浏览器处理的URL最大限度长度为1024B（不同浏览器不一样），所以GET方法提交参数长度有限制。</p><p>​        “post”方法提交的数据会附在正文上，一般请求正文的长度是没有限制的，但表单中所能处理的长度一般为100k（不同协议不同浏览器不一样）,而且需要考虑下层报文的传输效率，不推荐过长。</p><p>​        所以GET方法可以用来传输一些可以公开的参数信息，解析也比较方便，如百度的搜索的关键词，而POST方法可以用来提交一个用户的敏感信息（如果不使用HTTPS加密，报文正文仍旧是明文，容易被人截获读取）</p><img src="/2020/12/04/get-he-post-de-qu-bie/get-he-post-de-qu-bie/get%E5%92%8Cpost%E5%8C%BA%E5%88%AB.png" class="">]]></content>
      
      
      <categories>
          
          <category> 请求方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> get-post </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B/S和C/S的区别</title>
      <link href="2020/12/04/bs-he-cs-de-qu-bie/"/>
      <url>2020/12/04/bs-he-cs-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><pre class=" language-python"><code class="language-python">    C<span class="token operator">/</span>S结构，即Client<span class="token operator">/</span>Server<span class="token punctuation">(</span>客户机<span class="token operator">/</span>服务器<span class="token punctuation">)</span>结构，是大家熟知的软件系统体系结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可以充分利用两端硬件环境的优势。早期的软件系统多以此作为首选设计标准。     B<span class="token operator">/</span>S结构，即Browser<span class="token operator">/</span>Server<span class="token punctuation">(</span>浏览器<span class="token operator">/</span>服务器<span class="token punctuation">)</span>结构，是随着Internet技术的兴起，对C<span class="token operator">/</span>S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，形成所谓<span class="token number">3</span><span class="token operator">-</span>tier结构。B<span class="token operator">/</span>S结构，主要是利用了不断成熟的WWW浏览器技术，结合浏览器的多种Script语言<span class="token punctuation">(</span>VBScript、JavaScript…<span class="token punctuation">)</span>和ActiveX技术，用通用浏览器就实现了原来需要复杂专用软件才能实现的强大功能，并节约了开发成本，是一种全新的软件系统构造技术。随着Windows <span class="token number">98</span><span class="token operator">/</span>Windows <span class="token number">2000</span>将浏览器技术植入操作系统内部，这种结构更成为当今应用软件的首选体系结构。</code></pre><h3 id="C-S和B-S的区别："><a href="#C-S和B-S的区别：" class="headerlink" title="C/S和B/S的区别："></a>C/S和B/S的区别：</h3><pre class=" language-python"><code class="language-python">Client<span class="token operator">/</span>Server是建立在局域网的基础上的<span class="token punctuation">.</span>Browser<span class="token operator">/</span>Server是建立在广域网的基础上的<span class="token punctuation">,</span>但并不是说B<span class="token operator">/</span>S结构不能在局域网上使用<span class="token punctuation">,</span>如智赢IPOWER<span class="token punctuation">,</span>在单机<span class="token punctuation">,</span>局限网<span class="token punctuation">,</span>广域网均能使用。<span class="token number">1</span>．硬件环境不同<span class="token punctuation">:</span> C<span class="token operator">/</span>S 一般建立在专用的网络上<span class="token punctuation">,</span> 小范围里的网络环境<span class="token punctuation">,</span> 局域网之间再通过专门服务器提供连接和数据交换服务<span class="token punctuation">.</span> B<span class="token operator">/</span>S 建立在广域网之上的<span class="token punctuation">,</span> 不必是专门的网络硬件环境<span class="token punctuation">,</span>例与电话上网<span class="token punctuation">,</span> 租用设备<span class="token punctuation">.</span> 信息自己管理<span class="token punctuation">.</span> 有比C<span class="token operator">/</span>S更强的适应范围<span class="token punctuation">,</span> 一般只要有操作系统和浏览器就行 <span class="token number">2</span>．对安全要求不同 C<span class="token operator">/</span>S 对服务端、客户端都安全都要考虑。B<span class="token operator">/</span>S 因没有客户端，所以只注重服务端安全即可。<span class="token number">3</span>．对程序架构不同 C<span class="token operator">/</span>S 程序可以更加注重流程<span class="token punctuation">,</span> 可以对权限多层次校验<span class="token punctuation">,</span> 对系统运行速度可以较少考虑<span class="token punctuation">.</span> B<span class="token operator">/</span>S 对安全以及访问速度的多重的考虑<span class="token punctuation">,</span> 建立在需要更加优化的基础之上<span class="token punctuation">.</span> 比C<span class="token operator">/</span>S有更高的要求 B<span class="token operator">/</span>S结构的程序架构是发展的趋势<span class="token punctuation">,</span> 从MS的<span class="token punctuation">.</span>Net系列的BizTalk <span class="token number">2000</span> Exchange <span class="token number">2000</span>等<span class="token punctuation">,</span> 全面支持网络的构件搭建的系统<span class="token punctuation">.</span> SUN 和IBM推的JavaBean 构件技术等<span class="token punctuation">,</span>使 B<span class="token operator">/</span>S更加成熟<span class="token punctuation">.</span> 例如智赢IPOWER，采用AJAX和数据存储优化技术，相比一般B<span class="token operator">/</span>S架构软件速度提高<span class="token number">30</span><span class="token operator">%</span>至<span class="token number">99</span><span class="token operator">%</span>。<span class="token number">4</span>．软件重用不同 C<span class="token operator">/</span>S 程序可以不可避免的整体性考虑<span class="token punctuation">,</span> 构件的重用性不如在B<span class="token operator">/</span>S要求下的构件的重用性好<span class="token punctuation">.</span> B<span class="token operator">/</span>S 对的多重结构<span class="token punctuation">,</span>要求构件相对独立的功能<span class="token punctuation">.</span> 能够相对较好的重用<span class="token punctuation">.</span>就入买来的餐桌可以再利用<span class="token punctuation">,</span>而不是做在墙上的石头桌子 <span class="token number">5</span>．系统维护不同 系统维护是软件生存周期中<span class="token punctuation">,</span>开销大<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>重要 C<span class="token operator">/</span>S 程序由于整体性<span class="token punctuation">,</span> 必须整体考察<span class="token punctuation">,</span> 处理出现的问题以及系统升级<span class="token punctuation">.</span> 升级难<span class="token punctuation">.</span> 可能是再做一个全新的系统 B<span class="token operator">/</span>S 构件组成<span class="token punctuation">,</span>方面构件个别的更换<span class="token punctuation">,</span>实现系统的无缝升级<span class="token punctuation">.</span> 系统维护开销减到最小<span class="token punctuation">.</span>用户从网上自己下载安装就可以实现升级<span class="token punctuation">.</span> <span class="token number">6</span>．处理问题不同 C<span class="token operator">/</span>S 程序可以处理用户面固定<span class="token punctuation">,</span> 并且在相同区域<span class="token punctuation">,</span> 安全要求高需求<span class="token punctuation">,</span> 与操作系统相关<span class="token punctuation">.</span> 应该都是相同的系统 B<span class="token operator">/</span>S 建立在广域网上<span class="token punctuation">,</span> 面向不同的用户群<span class="token punctuation">,</span> 分散地域<span class="token punctuation">,</span> 这是C<span class="token operator">/</span>S无法作到的<span class="token punctuation">.</span> 与操作系统平台关系最小<span class="token punctuation">.</span> <span class="token number">7</span>．用户接口不同 C<span class="token operator">/</span>S 多是建立的Window平台上<span class="token punctuation">,</span>表现方法有限<span class="token punctuation">,</span>对程序员普遍要求较高 B<span class="token operator">/</span>S 建立在浏览器上<span class="token punctuation">,</span> 通过WEB服务或其他公共可识别描述语言可跨平台，使用更灵活。不仅可应用在Window平台上，还可应用于unix<span class="token operator">/</span>Linux等平台。<span class="token number">8</span>．信息流不同 C<span class="token operator">/</span>S 程序一般是典型的中央集权的机械式处理<span class="token punctuation">,</span> 交互性相对低 B<span class="token operator">/</span>S 信息流向可变化<span class="token punctuation">,</span> B<span class="token operator">-</span>B B<span class="token operator">-</span>C B<span class="token operator">-</span>G等信息、流向的变化<span class="token punctuation">,</span> 更象交易中心。</code></pre>]]></content>
      
      
      <categories>
          
          <category> B/S C/S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B/S C/S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/04/badboy-can-shu-lu-zhi/badboy-can-shu-lu-zhi/"/>
      <url>2020/12/04/badboy-can-shu-lu-zhi/badboy-can-shu-lu-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="打开badboy搜索框输入需要录制的网址进行访问"><a href="#打开badboy搜索框输入需要录制的网址进行访问" class="headerlink" title="打开badboy搜索框输入需要录制的网址进行访问"></a>打开badboy搜索框输入需要录制的网址进行访问</h3><img src="/2020/12/04/badboy-can-shu-lu-zhi/badboy-can-shu-lu-zhi/1.png" class=""><h3 id="开始对web网址的信息进行录制，在网页中操作之后，会保存所有的信息"><a href="#开始对web网址的信息进行录制，在网页中操作之后，会保存所有的信息" class="headerlink" title="开始对web网址的信息进行录制，在网页中操作之后，会保存所有的信息"></a>开始对web网址的信息进行录制，在网页中操作之后，会保存所有的信息</h3><img src="/2020/12/04/badboy-can-shu-lu-zhi/badboy-can-shu-lu-zhi/2.png" class=""><h3 id="需要停止录制再次点击红色录制即可，录制完毕左边已经生成录制的脚步"><a href="#需要停止录制再次点击红色录制即可，录制完毕左边已经生成录制的脚步" class="headerlink" title="需要停止录制再次点击红色录制即可，录制完毕左边已经生成录制的脚步"></a>需要停止录制再次点击红色录制即可，录制完毕左边已经生成录制的脚步</h3><img src="/2020/12/04/badboy-can-shu-lu-zhi/badboy-can-shu-lu-zhi/3.png" class=""><h3 id="完成录制后，需要进行把脚本导出，点击菜单中的file选择菜单"><a href="#完成录制后，需要进行把脚本导出，点击菜单中的file选择菜单" class="headerlink" title="完成录制后，需要进行把脚本导出，点击菜单中的file选择菜单"></a>完成录制后，需要进行把脚本导出，点击菜单中的file选择菜单</h3><h3 id="下拉框选择-export-to-jmeter"><a href="#下拉框选择-export-to-jmeter" class="headerlink" title="下拉框选择 export to jmeter"></a>下拉框选择 export to jmeter</h3><img src="/2020/12/04/badboy-can-shu-lu-zhi/badboy-can-shu-lu-zhi/4.png" class=""><h3 id="本地会出现脚本文件-jmeter-直接调用即可"><a href="#本地会出现脚本文件-jmeter-直接调用即可" class="headerlink" title="本地会出现脚本文件 jmeter 直接调用即可"></a>本地会出现脚本文件 jmeter 直接调用即可</h3><h3 id="直接拖动到jmeter窗口即可-参数自动填充-可进行后续操作"><a href="#直接拖动到jmeter窗口即可-参数自动填充-可进行后续操作" class="headerlink" title="直接拖动到jmeter窗口即可 参数自动填充 可进行后续操作"></a>直接拖动到jmeter窗口即可 参数自动填充 可进行后续操作</h3><img src="/2020/12/04/badboy-can-shu-lu-zhi/badboy-can-shu-lu-zhi/5.png" class="">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>APP端如何测试</title>
      <link href="2020/12/04/app-duan-ru-he-ce-shi/"/>
      <url>2020/12/04/app-duan-ru-he-ce-shi/</url>
      
        <content type="html"><![CDATA[<p>​    首先拿到项目原型图或者思维导图然后进行具体的：</p><p>​    功能测试：每项开发的新功能都要进行测试，功能测试是App中的重要方面，要进行手动测试和后期的自动化测试，刚开始测试时要把App当做“黑盒测试”，看功能是否正常，除了经典测试以外，像点击按钮、提交订单…等等，看会出现什么情况。</p><p>​    客户端性能测试：App好不好，不仅仅时功能展示，在高端机正常运行，中/低端机型卡的不行，这也不能算是好的App。关于性能测试主要是：cup、内存、耗电量、流量、FPS..等</p><p>​    适配兼容测试：不同机型/不同品牌/不同系统测试</p><p>​    安全测试： </p><p>​        用户隐私</p><p>​            检查是bai否在本地保存用户密码，无论加密与否</p><p>​            检查敏感的隐私信息，如聊天记录、关系链、银行账号等是否进行加密</p><p>​            检查是否将系统文件、配置文件明文保存在外部设备上</p><p>​            部分需要存储到外部设备的信息，需要每次使用前都判断信息是否被篡改</p><p>​        文件权限</p><p>​            检查App所在的目录，其权限必须为不允许其他组成员读写</p><p>​        网络通讯</p><p>​            检查敏感信息在网络传输中是否做了加密处理，重要数据要采用TLS或者SSL</p><p>​        运行时解释保护</p><p>​            对于嵌有解释器的软件，检查是否存在XSS、SQL注入漏洞</p><p>​            使用webiew的App，检查是否存在URL欺骗漏洞</p><p>​        Android组件权限保护</p><p>​            禁止App内部组件被任意第三方程序调用。</p><p>​            若需要供外部调用的组件，应检查对调用者是否做了签名限制</p><p>​        升级</p><p>​            检查是否对升级包的完整性、合法性进行了校验，避免升级包被劫持</p><p>​        3rd库</p><p>​            如果使用了第三方库，需要跟进第三方库的更新</p><p>​    服务器性能测试：服务器性能测试，主要包含单机容量测试和24小时稳定性测试。单机容量测试，可以检测到单机服务器在90%的响应时间和成功率都达标的前提下，能够承载多少用户量。使用特定游戏模型压测24小时，服务无重启，内存无泄漏，并且各事务成功率达标。</p>]]></content>
      
      
      <categories>
          
          <category> APP端如何测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APP端如何测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANR--以及如何定位是前端问题还是后台问题？</title>
      <link href="2020/12/04/anr-yi-ji-ru-he-ding-wei-shi-qian-duan-wen-ti-huan-shi-hou-tai-wen-ti/"/>
      <url>2020/12/04/anr-yi-ji-ru-he-ding-wei-shi-qian-duan-wen-ti-huan-shi-hou-tai-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>1.ANR</p><p>在baiAndroid上，如果你的应用程序有一段时du间响应不够灵敏zhi，系统会向用户显示一个对话框，dao这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</p><p>一般来说，在应用程序里，100到200ms是用户能感知阻滞的时间阈值。因此，这里有一些额外的技巧来避免ANR，并有助于让你的应用程序看起来有响应性。</p><p>如果你的应用程序为响应用户输入正在后台工作的话，可以显示工作的进度（ProgressBar和ProgressDialog对这种情况来说很有用）。</p><p>特别是游戏，在子线程里做移动的计算。<br>如果你的应用程序有一个耗时的初始化过程的话，考虑可以显示一个Splash Screen或者快速显示主画面并异步来填充这些信息。在这两种情况下，你都应该显示正在进行的进度，以免用户认为应用程序被冻结了。</p><p>2.以及如何定位是前端问题还是后台问题？</p><p>第一步bai先去数据库里查,看我们做数据查询操作du时数据库里对应zhi数据是对是错,如果说数据库中都出dao错了,那可能就是数据本身的问题,就要进一步看存数据时哪里出错;</p><p>如果数据库里是对的,那第二步就要抓包,查看抓包响应里返回的结果是不是正确,如果正确,那就是前端页面出错.</p><p>如果返回的结果是错的,那就要分两种情况来看,第一种是前端发送的请求是否正确(有可能是函数错误或者请求参数错了),如果错误那就是前端问题,如果正确,那就是后端处理问题</p>]]></content>
      
      
      <categories>
          
          <category> ANR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>划分测试用例优先级</title>
      <link href="2020/12/04/1.hua-fen-ce-shi-yong-li-you-xian-ji-de-hao-chu/"/>
      <url>2020/12/04/1.hua-fen-ce-shi-yong-li-you-xian-ji-de-hao-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-划分测试用例优先级的好处"><a href="#1-划分测试用例优先级的好处" class="headerlink" title="1.划分测试用例优先级的好处"></a>1.划分测试用例优先级的好处</h2><p>​    没有软件系统时完美的，任何系统都有BUGS。但是每一次的迭代都有一个期望，测试工程师有知道本次迭代的项目关系人的预期，找到对应的目标和风险。</p><p>​    二八原则： 10%到15%的测试用例发现被测系统的75%到90%的BUGS。</p><hr><h2 id="2-怎么划分优先级呢"><a href="#2-怎么划分优先级呢" class="headerlink" title="2.怎么划分优先级呢"></a>2.怎么划分优先级呢</h2><p>​    我相信你肯定也遇见过如下场景，面对成百上千的测试用例，要挑选一个最小的，最终要的，优先级最高的测试用例的时候却无法下手。对测试用例进行优先级的定义并不容易，而优先级的定义在每一次迭代中或者迭代后都有可能修改。因此<strong>测试用例的优先级是动态的。</strong></p><hr><ol><li><h3 id="构建验证测试（BVT）"><a href="#构建验证测试（BVT）" class="headerlink" title="构建验证测试（BVT）"></a>构建验证测试（BVT）</h3><p>​    BVT也称之为冒烟测试用例集。是每次测试开始allin投入前最希望被运行得以确认的测试用例集。</p><p>​    冒烟测试用例集的规则： 如果该用例无法正确执行成功，其他测试用例都没法办法执行。如果满足该条件的测试用例，那么就应该纳入冒烟测试用例集。</p></li><li><h3 id="高优先级"><a href="#高优先级" class="headerlink" title="高优先级"></a>高优先级</h3><p>​    高优先级测试用例集合是按照执行频度和业务功树的根部分支的条件选入的。</p><p>​    高优先级测试用例的规则： BVT中加入最常用的测试用例，用来验证重要或者主干流程的功能稳定，功能正确。测试用例中既包含了正确的数据流也包含了错误的数据流。</p></li><li><h3 id="中优先级"><a href="#中优先级" class="headerlink" title="中优先级"></a>中优先级</h3><p>​    中优先级测试用例集合是按照执行频度和业务功树的主要分支的条件选入的。</p><p>​    中优先级测试用例的规则： 在新迭代影响域（新功能区域）或者功能更加详尽。测试用例包含了大多数方面的功能，其中除了有正确数据流和错误的数据流，还应该有一些配置方面的测试。</p></li><li><h3 id="低优先级"><a href="#低优先级" class="headerlink" title="低优先级"></a>低优先级</h3><p>​    低优先级测试用例集合是按照执行频度和业务功树的根部分支的条件选入的。</p><p>​    低优先级测试用例的规则： 这个是最不频繁的测试用例执行部分。但是低并不是说不执行，不测试。只是在迭代的过程汇总，执行频率比较低，不常常被执行。例如：错误信息，可用性，压力和性能测试等。</p></li></ol><hr><h2 id="3-开始划分你的测试用例"><a href="#3-开始划分你的测试用例" class="headerlink" title="3.开始划分你的测试用例"></a>3.开始划分你的测试用例</h2><h3 id="1-粗狂划分，任意标注"><a href="#1-粗狂划分，任意标注" class="headerlink" title="1. 粗狂划分，任意标注"></a>1. 粗狂划分，任意标注</h3><p>​    将全部功能的正确性验证（happy path）的测试用例定义为高优先级；</p><p>​    将全部由错误或者有边界值验证的测试用例定义为中优先级；</p><p>​    将其他定义为低优先级（这里面主要是非功能测试用例）；</p><h3 id="2-Review-每一个测试用例，升级或者降级"><a href="#2-Review-每一个测试用例，升级或者降级" class="headerlink" title="2. Review 每一个测试用例，升级或者降级"></a>2. Review 每一个测试用例，升级或者降级</h3><p>​    通过对每一个测试用例以及其优先级的标记的重新review，开课测试的重要性以及执行频度等，按照下面进行降级处理。</p><p>​    将功能验证测试分为两组重要和非重要，将“不太重要” 的功能验证测试降级为中等优先级；</p><p>​    将错误和边界测试分为两组重要和非重要，将“重要” 错误和边界测试推广到高优先级；</p><p>​    将非功能性测试分为两组重要和非重要，将“重要” 非功能性测试推广到中等优先级；</p><p>​    对每组高，中，低优先级测试用例重复划分和升 / 降级过程，直到达到优先级之间移动的测试用例数量变为0，终止。</p><h3 id="3-确定BVT"><a href="#3-确定BVT" class="headerlink" title="3. 确定BVT"></a>3. 确定BVT</h3><p>​    将高优先级测试分为两组，分别为致命和严重（如果出BUG就是致命BUG,那么这条测试用例也设定为致命。 将致命的测试用例归并到BVT优先级。）</p><p>​    相对统计的优先级分布BVT 10%-15% ,高 20%-30%，中40%-60% 和低10%-15%。</p>]]></content>
      
      
      <categories>
          
          <category> 测试优先级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试优先级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter断言</title>
      <link href="2020/12/03/jmeter/jmeter-duan-yan/"/>
      <url>2020/12/03/jmeter/jmeter-duan-yan/</url>
      
        <content type="html"><![CDATA[<p><strong>断言：</strong>验证服务器返回的数据是否满足我们的要求<br> 即LR中的检查点，是对响应结果做一个判断，我们在请求一个网址时会有返回数据，那怎么判断请求是正确的呢，就需要对某一字段或内容进行匹配，如果跟预想的一样就认为请求是正确的，否则是失败的</p><p>使用断言的目的：在request的返回层面增加一层判断机制（因为request成功了，并不代表结果一定正确）</p><p><strong>针对何时使用JMeter断言，下面给出了一些建议：</strong><br> （1）请求使用的是来自“CSV数据集配置”的数据<br> （2）使用的HTTP的POST、PUT、PATCH方法<br> （3）登录和注销后<br> （4）当2xx status codes同时在正面测试和负面测试中返回<br> （5）在API性能测试中<br> （6）在功能测试中<br> （7）有SOAP / XML-RPC请求<br> <strong>需要注意：断言消耗内存，谨慎使用</strong></p><h3 id="断言类型"><a href="#断言类型" class="headerlink" title="断言类型"></a>断言类型</h3><p>如果没有断言只能人工对比对接口返回的数据，接口很多时，比对数据的过程就会非常耗时，而且也容易出错，可以通过Fiddler抓包http请求来设置</p><h5 id="1、响应断言"><a href="#1、响应断言" class="headerlink" title="1、响应断言"></a>1、响应断言</h5><p>在使用该断言时，需要熟练使用正则表达式，如果请求中使用了变量，响应内容里写${variable}</p><p><img src="https://upload-images.jianshu.io/upload_images/5999951-ae6f386241ae0c7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1019/format/webp" alt="img"></p><p>抓包查看Resopnse.png</p><p>允许用户通过添加模式字符串来比较验证服务器返回的响应，Jmeter提供了很多种匹配规则，断言中设置要测试的模式，实际响应的内容与设计的字符串进行匹配，如果返回的内容包含了字符串，则认为该次测试通过，否则就是失败（模式中的内容也可以参数化）</p><p>对断言做判断，只需添加【监听器–断言结果】<br> 1）<strong>如果断言成功，显示的是HTTP请求名称</strong><br> 2）若失败，则会显示请求名称和失败的原因（“Test failed XXXXXX”内容）</p><p><strong>PS：一个Sampler可以添加多个断言，根据你的检查需求来添加相应的断言，当Sampler下所有的断言都通过了，才算成功 比如在测接口时，返回值是True，只能说明接口是通的，还得继续验证返回的data值是否正确</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5999951-d47bec560a1af12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/917/format/webp" alt="img"></p><p>断言.png</p><ul><li>Apply to：一般情况下，使用默认的就行，如果一次发送多个请求（Ajax请求，GET或POST），就需要根据实际断言需要选择其他选项了。</li><li>要测试的响应字段：根据实际需要选择 <ul><li>响应文本<br> 服务器响应文本，一般情况下，我们都是勾选改选项，用于验证服务器返回值。</li><li>Document（text）<br> 通过Apache Tika从各种的文档中提取的文本进行验证，包括响应文本，pdf、word等等各种格式。jmeter会用Apache Tika去解析服务器响应内容，耗内存、也耗时间，解析易失败，尽量少用或不用。多用响应文本方式来进行断言验证</li><li>URL样本<br> 对请求的url进行断言，如果请求没有重定向(302)，那么该url即为请求的url；如果有重定向（切跟随重定向），那么url则包含了请求url和重定向url。</li><li>响应代码<br> 即http响应代码，例如200，404等等，需要注意： 由于jmeter默认情况下认为4xx，5xx时该请求失败，所以在断言这类响应代码时，需要同时勾选Ingore Status，才能正常去做断言。</li><li>响应信息<br> 即响应代码对应的信息，例如OK， Not Found等等这类的。</li><li>Ingore Status 请参见4响应代码的使用说明。</li></ul></li></ul><p>如下常见类似是响应信息，即http响应头信息，主要用于断言当响应头带有唯一或特定意义</p><pre class=" language-dart"><code class="language-dart">      HTTP<span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> Ok      HTTP<span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">302</span> Found      Response Header <span class="token punctuation">:</span> 响应头信息，例如      Server<span class="token punctuation">:</span> Tengine      Date<span class="token punctuation">:</span> Thu<span class="token punctuation">,</span> <span class="token number">12</span> Mar <span class="token number">2015</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">43</span><span class="token punctuation">:</span><span class="token number">52</span> GMT      Content<span class="token operator">-</span>Type<span class="token punctuation">:</span> text<span class="token operator">/</span>html      Content<span class="token operator">-</span>Length<span class="token punctuation">:</span> 260Connection<span class="token punctuation">:</span> close      Location<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token number">404</span><span class="token punctuation">.</span>html      Response Headers</code></pre><ul><li>模式匹配规则：支持正则表达式 <ul><li>包括：返回结果包括指定的内容，当返回值固定时，可以使用返回值做断言，效果和equals相同</li><li>匹配：用正则表达式必须能匹配整个返回值，而不是返回值的一部分</li><li>Equals：返回结果与你指定结果完全一致</li><li>Substring：返回结果是指定结果的字串，不支持正则字符串</li><li>否：相当于取反，即如果上述断言结果为true，勾选“否”选项后，则最终断言结果为false</li></ul></li><li>要测试的模式：要匹配的响应值（字符串或正则表达式），即接口测试结果的期望值或者其他期望值</li></ul><p>转自：<a href="https://www.jianshu.com/p/9d6752c8b565">https://www.jianshu.com/p/9d6752c8b565</a></p>]]></content>
      
      
      <categories>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter连接数据库</title>
      <link href="2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/"/>
      <url>2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h3 id="导入Jar包"><a href="#导入Jar包" class="headerlink" title="导入Jar包"></a>导入Jar包</h3><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E5%AF%BC%E5%8C%85.png" class="" title="This is an 导包 image"><h3 id="创建元件"><a href="#创建元件" class="headerlink" title="创建元件"></a>创建元件</h3><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E5%88%9B%E5%BB%BA%E5%85%83%E4%BB%B6.png" class="" title="This is an 创建元件 image"><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E5%8F%82%E6%95%B0.png" class="" title="This is an 参数 image"><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E6%93%8D%E4%BD%9C1.png" class="" title="This is an 操作1 image"><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E6%93%8D%E4%BD%9C2.png" class="" title="This is an 操作2 image"><p>多语句执行</p><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E5%A4%9ASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C1.png" class="" title="This is an 多SQL语句执行1 image"><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E5%A4%9ASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C2.png" class="" title="This is an 多SQL语句执行2 image"><img src="/2020/12/03/jmeter/jmeter-lian-jie-shu-ju-ku/%E5%A4%9ASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C3.png" class="" title="This is an 多SQL语句执行3 image">]]></content>
      
      
      <categories>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter移动端录制</title>
      <link href="2020/12/03/jmeter/jmeter-yi-dong-duan-lu-zhi/"/>
      <url>2020/12/03/jmeter/jmeter-yi-dong-duan-lu-zhi/</url>
      
        <content type="html"><![CDATA[<p>Jmeter移动端录制</p><p>前置条件： 本机与移动端必须保持在同一个网段上</p><p>友情提示：移动端录制https网址不下载https证书的话参数会出现乱码</p><p>可用Fiddler提供的Https证书源  在移动端网址输入：</p><p>http://本机IP地址:8888/进行证书下载</p><h3 id="测试计划右键创建非测试元件下的HTTP代理服务器"><a href="#测试计划右键创建非测试元件下的HTTP代理服务器" class="headerlink" title="测试计划右键创建非测试元件下的HTTP代理服务器"></a>测试计划右键创建非测试元件下的HTTP代理服务器</h3><img src="/2020/12/03/jmeter/jmeter-yi-dong-duan-lu-zhi/1.png" class="" title="This is an image"><h3 id="为测试计划添加一个线程组-HTTP代理服务器的目标监控器指向刚创建的线程组-进行"><a href="#为测试计划添加一个线程组-HTTP代理服务器的目标监控器指向刚创建的线程组-进行" class="headerlink" title="为测试计划添加一个线程组,HTTP代理服务器的目标监控器指向刚创建的线程组 进行"></a>为测试计划添加一个线程组,HTTP代理服务器的目标监控器指向刚创建的线程组 进行</h3><h3 id="会讲录制的脚步保存到线程组里"><a href="#会讲录制的脚步保存到线程组里" class="headerlink" title="会讲录制的脚步保存到线程组里"></a>会讲录制的脚步保存到线程组里</h3><img src="/2020/12/03/jmeter/jmeter-yi-dong-duan-lu-zhi/2.png" class="" title="This is an image"><h3 id="移动端配置"><a href="#移动端配置" class="headerlink" title="移动端配置"></a>移动端配置</h3><h3 id="长按连接到的网络-点击修改网络-点击显示高级选择-将代理改为手动"><a href="#长按连接到的网络-点击修改网络-点击显示高级选择-将代理改为手动" class="headerlink" title="长按连接到的网络 点击修改网络 点击显示高级选择 将代理改为手动"></a>长按连接到的网络 点击修改网络 点击显示高级选择 将代理改为手动</h3><h3 id="在本机查看连接到网络的IPv4-的地址填写到-移动端的服务器主机名"><a href="#在本机查看连接到网络的IPv4-的地址填写到-移动端的服务器主机名" class="headerlink" title="在本机查看连接到网络的IPv4 的地址填写到 移动端的服务器主机名"></a>在本机查看连接到网络的IPv4 的地址填写到 移动端的服务器主机名</h3><img src="/2020/12/03/jmeter/jmeter-yi-dong-duan-lu-zhi/3.png" class="" title="This is an image"><p>端口号为：8888</p><p>开始录制即可</p><img src="/2020/12/03/jmeter/jmeter-yi-dong-duan-lu-zhi/4.png" class="" title="This is an image"><p>效果：</p><img src="/2020/12/03/jmeter/jmeter-yi-dong-duan-lu-zhi/5.png" class="" title="This is an image">]]></content>
      
      
      <categories>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter测试接口</title>
      <link href="2020/12/03/jmeter/jmeter-ce-shi-jie-kou/"/>
      <url>2020/12/03/jmeter/jmeter-ce-shi-jie-kou/</url>
      
        <content type="html"><![CDATA[<h3 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h3><img src="/2020/12/03/jmeter/jmeter-ce-shi-jie-kou/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%BB%841.png" class="" title="This is an 创建线程组 image"><h3 id="添加HTTP请求"><a href="#添加HTTP请求" class="headerlink" title="添加HTTP请求"></a>添加HTTP请求</h3><img src="/2020/12/03/jmeter/jmeter-ce-shi-jie-kou/%E6%B7%BB%E5%8A%A0http%E8%AF%B7%E6%B1%821.png" class="" title="This is an 添加http请求1 image"><img src="/2020/12/03/jmeter/jmeter-ce-shi-jie-kou/%E6%B7%BB%E5%8A%A0http%E8%AF%B7%E6%B1%822.png" class="" title="This is an 添加http请求2 image"><p>查看结果树</p><img src="/2020/12/03/jmeter/jmeter-ce-shi-jie-kou/%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C%E6%A0%91.png" class="" title="This is an 查看结果树 image">]]></content>
      
      
      <categories>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
